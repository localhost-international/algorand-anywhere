/* tslint:disable */
/* eslint-disable */
/**
 * Algod Mainnet V3 API v2
 * V2 API endpoint for algod operations.
 *
 * The version of the OpenAPI document: 3.15.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * Account information at a given round.  Definition: data/basics/userBalance.go : AccountData 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {AccountParticipation}
     * @memberof Account
     */
    'participation'?: AccountParticipation;
    /**
     * \\[tbx\\] The number of existing boxes created by this account\'s app.
     * @type {number}
     * @memberof Account
     */
    'total-boxes'?: number;
    /**
     * \\[algo\\] total number of MicroAlgos in the account
     * @type {number}
     * @memberof Account
     */
    'amount': number;
    /**
     * the account public key
     * @type {string}
     * @memberof Account
     */
    'address': string;
    /**
     * MicroAlgo balance required by the account. The requirement grows based on asset and application usage.
     * @type {number}
     * @memberof Account
     */
    'min-balance': number;
    /**
     * \\[appl\\] applications local data stored in this account.  Note the raw object uses `map[int] -> AppLocalState` for this type.
     * @type {Array<ApplicationLocalState>}
     * @memberof Account
     */
    'apps-local-state'?: Array<ApplicationLocalState>;
    /**
     * \\[apar\\] parameters of assets created by this account.  Note: the raw account uses `map[int] -> Asset` for this type.
     * @type {Array<Asset>}
     * @memberof Account
     */
    'created-assets'?: Array<Asset>;
    /**
     * 
     * @type {ApplicationStateSchema}
     * @memberof Account
     */
    'apps-total-schema'?: ApplicationStateSchema;
    /**
     * \\[ebase\\] used as part of the rewards computation. Only applicable to accounts which are participating.
     * @type {number}
     * @memberof Account
     */
    'reward-base'?: number;
    /**
     * amount of MicroAlgos of pending rewards in this account.
     * @type {number}
     * @memberof Account
     */
    'pending-rewards': number;
    /**
     * \\[appp\\] parameters of applications created by this account including app global data.  Note: the raw account uses `map[int] -> AppParams` for this type.
     * @type {Array<Application>}
     * @memberof Account
     */
    'created-apps'?: Array<Application>;
    /**
     * The count of all assets that have been opted in, equivalent to the count of AssetHolding objects held by this account.
     * @type {number}
     * @memberof Account
     */
    'total-assets-opted-in': number;
    /**
     * The count of all applications that have been opted in, equivalent to the count of application local data (AppLocalState objects) stored in this account.
     * @type {number}
     * @memberof Account
     */
    'total-apps-opted-in': number;
    /**
     * \\[tbxb\\] The total number of bytes used by this account\'s app\'s box keys and values.
     * @type {number}
     * @memberof Account
     */
    'total-box-bytes'?: number;
    /**
     * The count of all apps (AppParams objects) created by this account.
     * @type {number}
     * @memberof Account
     */
    'total-created-apps': number;
    /**
     * \\[asset\\] assets held by this account.  Note the raw object uses `map[int] -> AssetHolding` for this type.
     * @type {Array<AssetHolding>}
     * @memberof Account
     */
    'assets'?: Array<AssetHolding>;
    /**
     * \\[teap\\] the sum of all extra application program pages for this account.
     * @type {number}
     * @memberof Account
     */
    'apps-total-extra-pages'?: number;
    /**
     * The round for which this information is relevant.
     * @type {number}
     * @memberof Account
     */
    'round': number;
    /**
     * The count of all assets (AssetParams objects) created by this account.
     * @type {number}
     * @memberof Account
     */
    'total-created-assets': number;
    /**
     * specifies the amount of MicroAlgos in the account, without the pending rewards.
     * @type {number}
     * @memberof Account
     */
    'amount-without-pending-rewards': number;
    /**
     * \\[spend\\] the address against which signing should be checked. If empty, the address of the current account is used. This field can be updated in any transaction by setting the RekeyTo field.
     * @type {string}
     * @memberof Account
     */
    'auth-addr'?: string;
    /**
     * \\[ern\\] total rewards of MicroAlgos the account has received, including pending rewards.
     * @type {number}
     * @memberof Account
     */
    'rewards': number;
    /**
     * \\[onl\\] delegation status of the account\'s MicroAlgos * Offline - indicates that the associated account is delegated. *  Online  - indicates that the associated account used as part of the delegation pool. *   NotParticipating - indicates that the associated account is neither a delegator nor a delegate.
     * @type {string}
     * @memberof Account
     */
    'status': string;
    /**
     * Indicates what type of signature is used by this account, must be one of: * sig * msig * lsig
     * @type {string}
     * @memberof Account
     */
    'sig-type'?: AccountSigTypeEnum;
}

export const AccountSigTypeEnum = {
    Sig: 'sig',
    Msig: 'msig',
    Lsig: 'lsig'
} as const;

export type AccountSigTypeEnum = typeof AccountSigTypeEnum[keyof typeof AccountSigTypeEnum];

/**
 * AccountApplicationResponse describes the account\'s application local state and global state (AppLocalState and AppParams, if either exists) for a specific application ID. Global state will only be returned if the provided address is the application\'s creator.
 * @export
 * @interface AccountApplicationResponse
 */
export interface AccountApplicationResponse {
    /**
     * The round for which this information is relevant.
     * @type {number}
     * @memberof AccountApplicationResponse
     */
    'round': number;
    /**
     * 
     * @type {ApplicationParams}
     * @memberof AccountApplicationResponse
     */
    'created-app'?: ApplicationParams;
    /**
     * 
     * @type {ApplicationLocalState}
     * @memberof AccountApplicationResponse
     */
    'app-local-state'?: ApplicationLocalState;
}
/**
 * AccountAssetResponse describes the account\'s asset holding and asset parameters (if either exist) for a specific asset ID. Asset parameters will only be returned if the provided address is the asset\'s creator.
 * @export
 * @interface AccountAssetResponse
 */
export interface AccountAssetResponse {
    /**
     * 
     * @type {AssetHolding}
     * @memberof AccountAssetResponse
     */
    'asset-holding'?: AssetHolding;
    /**
     * The round for which this information is relevant.
     * @type {number}
     * @memberof AccountAssetResponse
     */
    'round': number;
    /**
     * 
     * @type {AssetParams}
     * @memberof AccountAssetResponse
     */
    'created-asset'?: AssetParams;
}
/**
 * AccountParticipation describes the parameters used by this account in consensus protocol.
 * @export
 * @interface AccountParticipation
 */
export interface AccountParticipation {
    /**
     * \\[stprf\\] Root of the state proof key (if any)
     * @type {string}
     * @memberof AccountParticipation
     */
    'state-proof-key'?: string;
    /**
     * \\[vote\\] root participation public key (if any) currently registered for this round.
     * @type {string}
     * @memberof AccountParticipation
     */
    'vote-participation-key': string;
    /**
     * \\[voteLst\\] Last round for which this participation is valid.
     * @type {number}
     * @memberof AccountParticipation
     */
    'vote-last-valid': number;
    /**
     * \\[voteKD\\] Number of subkeys in each batch of participation keys.
     * @type {number}
     * @memberof AccountParticipation
     */
    'vote-key-dilution': number;
    /**
     * \\[voteFst\\] First round for which this participation is valid.
     * @type {number}
     * @memberof AccountParticipation
     */
    'vote-first-valid': number;
    /**
     * \\[sel\\] Selection public key (if any) currently registered for this round.
     * @type {string}
     * @memberof AccountParticipation
     */
    'selection-participation-key': string;
}
/**
 * Application state delta.
 * @export
 * @interface AccountStateDelta
 */
export interface AccountStateDelta {
    /**
     * 
     * @type {string}
     * @memberof AccountStateDelta
     */
    'address': string;
    /**
     * Application state delta.
     * @type {Array<EvalDeltaKeyValue>}
     * @memberof AccountStateDelta
     */
    'delta': Array<EvalDeltaKeyValue>;
}
/**
 * An error response with optional data field.
 * @export
 * @interface ApigatewayError
 */
export interface ApigatewayError {
    /**
     * 
     * @type {string}
     * @memberof ApigatewayError
     */
    'data'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApigatewayError
     */
    'message': string;
}
/**
 * Application index and its parameters
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * \\[appidx\\] application index.
     * @type {number}
     * @memberof Application
     */
    'id': number;
    /**
     * 
     * @type {ApplicationParams}
     * @memberof Application
     */
    'params': ApplicationParams;
}
/**
 * Stores local state associated with an application.
 * @export
 * @interface ApplicationLocalState
 */
export interface ApplicationLocalState {
    /**
     * 
     * @type {ApplicationStateSchema}
     * @memberof ApplicationLocalState
     */
    'schema': ApplicationStateSchema;
    /**
     * Represents a key-value store for use in an application.
     * @type {Array<TealKeyValue>}
     * @memberof ApplicationLocalState
     */
    'key-value'?: Array<TealKeyValue>;
    /**
     * The application which this local state is for.
     * @type {number}
     * @memberof ApplicationLocalState
     */
    'id': number;
}
/**
 * Stores the global information associated with an application.
 * @export
 * @interface ApplicationParams
 */
export interface ApplicationParams {
    /**
     * Represents a key-value store for use in an application.
     * @type {Array<TealKeyValue>}
     * @memberof ApplicationParams
     */
    'global-state'?: Array<TealKeyValue>;
    /**
     * \\[clearp\\] approval program.
     * @type {string}
     * @memberof ApplicationParams
     */
    'clear-state-program': string;
    /**
     * The address that created this application. This is the address where the parameters and global state for this application can be found.
     * @type {string}
     * @memberof ApplicationParams
     */
    'creator': string;
    /**
     * 
     * @type {ApplicationStateSchema}
     * @memberof ApplicationParams
     */
    'local-state-schema'?: ApplicationStateSchema;
    /**
     * \\[approv\\] approval program.
     * @type {string}
     * @memberof ApplicationParams
     */
    'approval-program': string;
    /**
     * \\[epp\\] the amount of extra program pages available to this app.
     * @type {number}
     * @memberof ApplicationParams
     */
    'extra-program-pages'?: number;
    /**
     * 
     * @type {ApplicationStateSchema}
     * @memberof ApplicationParams
     */
    'global-state-schema'?: ApplicationStateSchema;
}
/**
 * Application information
 * @export
 * @interface ApplicationResponse
 */
export interface ApplicationResponse {
    /**
     * 
     * @type {Application}
     * @memberof ApplicationResponse
     */
    'application'?: Application;
}
/**
 * Specifies maximums on the number of each type that may be stored.
 * @export
 * @interface ApplicationStateSchema
 */
export interface ApplicationStateSchema {
    /**
     * \\[nui\\] num of uints.
     * @type {number}
     * @memberof ApplicationStateSchema
     */
    'num-uint': number;
    /**
     * \\[nbs\\] num of byte slices.
     * @type {number}
     * @memberof ApplicationStateSchema
     */
    'num-byte-slice': number;
}
/**
 * Specifies both the unique identifier and the parameters for an asset
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * unique asset identifier
     * @type {number}
     * @memberof Asset
     */
    'index': number;
    /**
     * 
     * @type {AssetParams}
     * @memberof Asset
     */
    'params': AssetParams;
}
/**
 * Describes an asset held by an account.  Definition: data/basics/userBalance.go : AssetHolding
 * @export
 * @interface AssetHolding
 */
export interface AssetHolding {
    /**
     * \\[a\\] number of units held.
     * @type {number}
     * @memberof AssetHolding
     */
    'amount': number;
    /**
     * Asset ID of the holding.
     * @type {number}
     * @memberof AssetHolding
     */
    'asset-id': number;
    /**
     * \\[f\\] whether or not the holding is frozen.
     * @type {boolean}
     * @memberof AssetHolding
     */
    'is-frozen': boolean;
}
/**
 * AssetParams specifies the parameters for an asset.  \\[apar\\] when part of an AssetConfig transaction.  Definition: data/transactions/asset.go : AssetParams
 * @export
 * @interface AssetParams
 */
export interface AssetParams {
    /**
     * The address that created this asset. This is the address where the parameters for this asset can be found, and also the address where unwanted asset units can be sent in the worst case.
     * @type {string}
     * @memberof AssetParams
     */
    'creator': string;
    /**
     * \\[un\\] Name of a unit of this asset, as supplied by the creator.
     * @type {string}
     * @memberof AssetParams
     */
    'unit-name'?: string;
    /**
     * \\[m\\] Address of account used to manage the keys of this asset and to destroy it.
     * @type {string}
     * @memberof AssetParams
     */
    'manager'?: string;
    /**
     * \\[am\\] A commitment to some unspecified asset metadata. The format of this metadata is up to the application.
     * @type {string}
     * @memberof AssetParams
     */
    'metadata-hash'?: string;
    /**
     * Base64 encoded URL where more information about the asset can be retrieved.
     * @type {string}
     * @memberof AssetParams
     */
    'url-b64'?: string;
    /**
     * \\[au\\] URL where more information about the asset can be retrieved. Included only when the URL is composed of printable utf-8 characters.
     * @type {string}
     * @memberof AssetParams
     */
    'url'?: string;
    /**
     * \\[c\\] Address of account used to clawback holdings of this asset.  If empty, clawback is not permitted.
     * @type {string}
     * @memberof AssetParams
     */
    'clawback'?: string;
    /**
     * \\[df\\] Whether holdings of this asset are frozen by default.
     * @type {boolean}
     * @memberof AssetParams
     */
    'default-frozen'?: boolean;
    /**
     * Base64 encoded name of a unit of this asset, as supplied by the creator.
     * @type {string}
     * @memberof AssetParams
     */
    'unit-name-b64'?: string;
    /**
     * \\[t\\] The total number of units of this asset.
     * @type {number}
     * @memberof AssetParams
     */
    'total': number;
    /**
     * \\[f\\] Address of account used to freeze holdings of this asset.  If empty, freezing is not permitted.
     * @type {string}
     * @memberof AssetParams
     */
    'freeze'?: string;
    /**
     * \\[dc\\] The number of digits to use after the decimal point when displaying this asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in tenths. If 2, the base unit of the asset is in hundredths, and so on. This value must be between 0 and 19 (inclusive).
     * @type {number}
     * @memberof AssetParams
     */
    'decimals': number;
    /**
     * \\[an\\] Name of this asset, as supplied by the creator. Included only when the asset name is composed of printable utf-8 characters.
     * @type {string}
     * @memberof AssetParams
     */
    'name'?: string;
    /**
     * \\[r\\] Address of account holding reserve (non-minted) units of this asset.
     * @type {string}
     * @memberof AssetParams
     */
    'reserve'?: string;
    /**
     * Base64 encoded name of this asset, as supplied by the creator.
     * @type {string}
     * @memberof AssetParams
     */
    'name-b64'?: string;
}
/**
 * Asset information
 * @export
 * @interface AssetResponse
 */
export interface AssetResponse {
    /**
     * 
     * @type {Asset}
     * @memberof AssetResponse
     */
    'asset'?: Asset;
}
/**
 * 
 * @export
 * @interface Block
 */
export interface Block {
    /**
     * Optional certificate object. This is only included when the format is set to message pack.
     * @type {object}
     * @memberof Block
     */
    'cert'?: object;
    /**
     * Block header data.
     * @type {object}
     * @memberof Block
     */
    'block': object;
}
/**
 * Hash of a block header.
 * @export
 * @interface BlockHashResponse
 */
export interface BlockHashResponse {
    /**
     * Block header hash.
     * @type {string}
     * @memberof BlockHashResponse
     */
    'blockHash': string;
}
/**
 * Encoded block object.
 * @export
 * @interface BlockResponse
 */
export interface BlockResponse {
    /**
     * Optional certificate object. This is only included when the format is set to message pack.
     * @type {object}
     * @memberof BlockResponse
     */
    'cert'?: object;
    /**
     * 
     * @type {Block}
     * @memberof BlockResponse
     */
    'block': Block;
}
/**
 * Box name and its content.
 * @export
 * @interface Box
 */
export interface Box {
    /**
     * \\[name\\] box name, base64 encoded
     * @type {string}
     * @memberof Box
     */
    'name': string;
    /**
     * \\[value\\] box value, base64 encoded.
     * @type {string}
     * @memberof Box
     */
    'value': string;
}
/**
 * Box descriptor describes a Box.
 * @export
 * @interface BoxDescriptor
 */
export interface BoxDescriptor {
    /**
     * Base64 encoded box name
     * @type {string}
     * @memberof BoxDescriptor
     */
    'name': string;
}
/**
 * Box information
 * @export
 * @interface BoxResponse
 */
export interface BoxResponse {
    /**
     * 
     * @type {Box}
     * @memberof BoxResponse
     */
    'box'?: Box;
}
/**
 * Box names of an application
 * @export
 * @interface BoxesResponse
 */
export interface BoxesResponse {
    /**
     * 
     * @type {Array<BoxDescriptor>}
     * @memberof BoxesResponse
     */
    'boxes': Array<BoxDescriptor>;
}
/**
 * 
 * @export
 * @interface CompileResponse
 */
export interface CompileResponse {
    /**
     * base64 encoded program bytes
     * @type {string}
     * @memberof CompileResponse
     */
    'result': string;
    /**
     * JSON of the source map
     * @type {object}
     * @memberof CompileResponse
     */
    'sourcemap'?: object;
    /**
     * base32 SHA512_256 of program bytes (Address style)
     * @type {string}
     * @memberof CompileResponse
     */
    'hash': string;
}
/**
 * Teal disassembly Result
 * @export
 * @interface DisassembleResponse
 */
export interface DisassembleResponse {
    /**
     * disassembled Teal code
     * @type {string}
     * @memberof DisassembleResponse
     */
    'result': string;
}
/**
 * Request data type for dryrun endpoint. Given the Transactions and simulated ledger state upload, run TEAL scripts and return debugging information.
 * @export
 * @interface DryrunRequest
 */
export interface DryrunRequest {
    /**
     * 
     * @type {Array<DryrunSource>}
     * @memberof DryrunRequest
     */
    'sources': Array<DryrunSource>;
    /**
     * Round is available to some TEAL scripts. Defaults to the current round on the network this algod is attached to.
     * @type {number}
     * @memberof DryrunRequest
     */
    'round': number;
    /**
     * 
     * @type {Array<Account>}
     * @memberof DryrunRequest
     */
    'accounts': Array<Account>;
    /**
     * ProtocolVersion specifies a specific version string to operate under, otherwise whatever the current protocol of the network this algod is running in.
     * @type {string}
     * @memberof DryrunRequest
     */
    'protocol-version': string;
    /**
     * LatestTimestamp is available to some TEAL scripts. Defaults to the latest confirmed timestamp this algod is attached to.
     * @type {number}
     * @memberof DryrunRequest
     */
    'latest-timestamp': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DryrunRequest
     */
    'txns': Array<string>;
    /**
     * 
     * @type {Array<Application>}
     * @memberof DryrunRequest
     */
    'apps': Array<Application>;
}
/**
 * DryrunResponse contains per-txn debug information from a dryrun.
 * @export
 * @interface DryrunResponse
 */
export interface DryrunResponse {
    /**
     * Protocol version is the protocol version Dryrun was operated under.
     * @type {string}
     * @memberof DryrunResponse
     */
    'protocol-version': string;
    /**
     * 
     * @type {string}
     * @memberof DryrunResponse
     */
    'error': string;
    /**
     * 
     * @type {Array<DryrunTxnResult>}
     * @memberof DryrunResponse
     */
    'txns': Array<DryrunTxnResult>;
}
/**
 * DryrunSource is TEAL source text that gets uploaded, compiled, and inserted into transactions or application state.
 * @export
 * @interface DryrunSource
 */
export interface DryrunSource {
    /**
     * FieldName is what kind of sources this is. If lsig then it goes into the transactions[this.TxnIndex].LogicSig. If approv or clearp it goes into the Approval Program or Clear State Program of application[this.AppIndex].
     * @type {string}
     * @memberof DryrunSource
     */
    'field-name': string;
    /**
     * 
     * @type {number}
     * @memberof DryrunSource
     */
    'app-index': number;
    /**
     * 
     * @type {string}
     * @memberof DryrunSource
     */
    'source': string;
    /**
     * 
     * @type {number}
     * @memberof DryrunSource
     */
    'txn-index': number;
}
/**
 * Stores the TEAL eval step data
 * @export
 * @interface DryrunState
 */
export interface DryrunState {
    /**
     * 
     * @type {Array<TealValue>}
     * @memberof DryrunState
     */
    'stack': Array<TealValue>;
    /**
     * Program counter
     * @type {number}
     * @memberof DryrunState
     */
    'pc': number;
    /**
     * Line number
     * @type {number}
     * @memberof DryrunState
     */
    'line': number;
    /**
     * 
     * @type {Array<TealValue>}
     * @memberof DryrunState
     */
    'scratch'?: Array<TealValue>;
    /**
     * Evaluation error if any
     * @type {string}
     * @memberof DryrunState
     */
    'error'?: string;
}
/**
 * DryrunTxnResult contains any LogicSig or ApplicationCall program debug information and state updates from a dryrun.
 * @export
 * @interface DryrunTxnResult
 */
export interface DryrunTxnResult {
    /**
     * Budget added during execution of app call transaction.
     * @type {number}
     * @memberof DryrunTxnResult
     */
    'budget-added'?: number;
    /**
     * 
     * @type {Array<AccountStateDelta>}
     * @memberof DryrunTxnResult
     */
    'local-deltas'?: Array<AccountStateDelta>;
    /**
     * Application state delta.
     * @type {Array<EvalDeltaKeyValue>}
     * @memberof DryrunTxnResult
     */
    'global-delta'?: Array<EvalDeltaKeyValue>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DryrunTxnResult
     */
    'logic-sig-messages'?: Array<string>;
    /**
     * Budget consumed during execution of app call transaction.
     * @type {number}
     * @memberof DryrunTxnResult
     */
    'budget-consumed'?: number;
    /**
     * Disassembled program line by line.
     * @type {Array<string>}
     * @memberof DryrunTxnResult
     */
    'disassembly': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DryrunTxnResult
     */
    'app-call-messages'?: Array<string>;
    /**
     * 
     * @type {Array<DryrunState>}
     * @memberof DryrunTxnResult
     */
    'logic-sig-trace'?: Array<DryrunState>;
    /**
     * 
     * @type {Array<DryrunState>}
     * @memberof DryrunTxnResult
     */
    'app-call-trace'?: Array<DryrunState>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DryrunTxnResult
     */
    'logs'?: Array<string>;
    /**
     * Disassembled lsig program line by line.
     * @type {Array<string>}
     * @memberof DryrunTxnResult
     */
    'logic-sig-disassembly'?: Array<string>;
}
/**
 * An error response with optional data field.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'data'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
}
/**
 * Represents a TEAL value delta.
 * @export
 * @interface EvalDelta
 */
export interface EvalDelta {
    /**
     * \\[bs\\] bytes value.
     * @type {string}
     * @memberof EvalDelta
     */
    'bytes'?: string;
    /**
     * \\[at\\] delta action.
     * @type {number}
     * @memberof EvalDelta
     */
    'action': number;
    /**
     * \\[ui\\] uint value.
     * @type {number}
     * @memberof EvalDelta
     */
    'uint'?: number;
}
/**
 * Key-value pairs for StateDelta.
 * @export
 * @interface EvalDeltaKeyValue
 */
export interface EvalDeltaKeyValue {
    /**
     * 
     * @type {EvalDelta}
     * @memberof EvalDeltaKeyValue
     */
    'value': EvalDelta;
    /**
     * 
     * @type {string}
     * @memberof EvalDeltaKeyValue
     */
    'key': string;
}
/**
 * Proof of membership and position of a light block header.
 * @export
 * @interface LightBlockHeaderProof
 */
export interface LightBlockHeaderProof {
    /**
     * Represents the depth of the tree that is being proven, i.e. the number of edges from a leaf to the root.
     * @type {number}
     * @memberof LightBlockHeaderProof
     */
    'treedepth': number;
    /**
     * The index of the light block header in the vector commitment tree
     * @type {number}
     * @memberof LightBlockHeaderProof
     */
    'index': number;
    /**
     * The encoded proof.
     * @type {string}
     * @memberof LightBlockHeaderProof
     */
    'proof': string;
}
/**
 * Proof of a light block header.
 * @export
 * @interface LightBlockHeaderProofResponse
 */
export interface LightBlockHeaderProofResponse {
    /**
     * 
     * @type {LightBlockHeaderProof}
     * @memberof LightBlockHeaderProofResponse
     */
    'LightBlockHeaderProof'?: LightBlockHeaderProof;
}
/**
 * NodeStatus contains the information about a node status
 * @export
 * @interface NodeStatusResponse
 */
export interface NodeStatusResponse {
    /**
     * LastVersion indicates the last consensus version supported
     * @type {string}
     * @memberof NodeStatusResponse
     */
    'last-version': string;
    /**
     * Next protocol round
     * @type {number}
     * @memberof NodeStatusResponse
     */
    'upgrade-next-protocol-vote-before'?: number;
    /**
     * The number of accounts from the current catchpoint that have been processed so far as part of the catchup
     * @type {number}
     * @memberof NodeStatusResponse
     */
    'catchpoint-processed-accounts'?: number;
    /**
     * The current catchpoint that is being caught up to
     * @type {string}
     * @memberof NodeStatusResponse
     */
    'catchpoint'?: string;
    /**
     * NextVersionRound is the round at which the next consensus version will apply
     * @type {number}
     * @memberof NodeStatusResponse
     */
    'next-version-round': number;
    /**
     * The total number of blocks that are required to complete the current catchpoint catchup
     * @type {number}
     * @memberof NodeStatusResponse
     */
    'catchpoint-total-blocks'?: number;
    /**
     * Total votes cast for consensus upgrade
     * @type {number}
     * @memberof NodeStatusResponse
     */
    'upgrade-votes'?: number;
    /**
     * This node\'s upgrade vote
     * @type {boolean}
     * @memberof NodeStatusResponse
     */
    'upgrade-node-vote'?: boolean;
    /**
     * Yes votes required for consensus upgrade
     * @type {number}
     * @memberof NodeStatusResponse
     */
    'upgrade-votes-required'?: number;
    /**
     * Upgrade delay
     * @type {number}
     * @memberof NodeStatusResponse
     */
    'upgrade-delay'?: number;
    /**
     * The number of blocks that have already been obtained by the node as part of the catchup
     * @type {number}
     * @memberof NodeStatusResponse
     */
    'catchpoint-acquired-blocks'?: number;
    /**
     * TimeSinceLastRound in nanoseconds
     * @type {number}
     * @memberof NodeStatusResponse
     */
    'time-since-last-round': number;
    /**
     * StoppedAtUnsupportedRound indicates that the node does not support the new rounds and has stopped making progress
     * @type {boolean}
     * @memberof NodeStatusResponse
     */
    'stopped-at-unsupported-round': boolean;
    /**
     * The number of key-values (KVs) from the current catchpoint that have been processed so far as part of the catchup
     * @type {number}
     * @memberof NodeStatusResponse
     */
    'catchpoint-processed-kvs'?: number;
    /**
     * NextVersionSupported indicates whether the next consensus version is supported by this node
     * @type {boolean}
     * @memberof NodeStatusResponse
     */
    'next-version-supported': boolean;
    /**
     * Total voting ounds for current upgrade
     * @type {number}
     * @memberof NodeStatusResponse
     */
    'upgrade-vote-rounds'?: number;
    /**
     * The last catchpoint seen by the node
     * @type {string}
     * @memberof NodeStatusResponse
     */
    'last-catchpoint'?: string;
    /**
     * The number of key-values (KVs) from the current catchpoint that have been verified so far as part of the catchup
     * @type {number}
     * @memberof NodeStatusResponse
     */
    'catchpoint-verified-kvs'?: number;
    /**
     * NextVersion of consensus protocol to use
     * @type {string}
     * @memberof NodeStatusResponse
     */
    'next-version': string;
    /**
     * Yes votes cast for consensus upgrade
     * @type {number}
     * @memberof NodeStatusResponse
     */
    'upgrade-yes-votes'?: number;
    /**
     * No votes cast for consensus upgrade
     * @type {number}
     * @memberof NodeStatusResponse
     */
    'upgrade-no-votes'?: number;
    /**
     * The total number of key-values (KVs) included in the current catchpoint
     * @type {number}
     * @memberof NodeStatusResponse
     */
    'catchpoint-total-kvs'?: number;
    /**
     * The total number of accounts included in the current catchpoint
     * @type {number}
     * @memberof NodeStatusResponse
     */
    'catchpoint-total-accounts'?: number;
    /**
     * LastRound indicates the last round seen
     * @type {number}
     * @memberof NodeStatusResponse
     */
    'last-round': number;
    /**
     * The number of accounts from the current catchpoint that have been verified so far as part of the catchup
     * @type {number}
     * @memberof NodeStatusResponse
     */
    'catchpoint-verified-accounts'?: number;
    /**
     * CatchupTime in nanoseconds
     * @type {number}
     * @memberof NodeStatusResponse
     */
    'catchup-time': number;
}
/**
 * Details about a pending transaction. If the transaction was recently confirmed, includes confirmation details like the round and reward details.
 * @export
 * @interface PendingTransactionResponse
 */
export interface PendingTransactionResponse {
    /**
     * Rewards in microalgos applied to the receiver account.
     * @type {number}
     * @memberof PendingTransactionResponse
     */
    'receiver-rewards'?: number;
    /**
     * The asset index if the transaction was found and it created an asset.
     * @type {number}
     * @memberof PendingTransactionResponse
     */
    'asset-index'?: number;
    /**
     * The round where this transaction was confirmed, if present.
     * @type {number}
     * @memberof PendingTransactionResponse
     */
    'confirmed-round'?: number;
    /**
     * Indicates that the transaction was kicked out of this node\'s transaction pool (and specifies why that happened).  An empty string indicates the transaction wasn\'t kicked out of this node\'s txpool due to an error. 
     * @type {string}
     * @memberof PendingTransactionResponse
     */
    'pool-error': string;
    /**
     * The raw signed transaction.
     * @type {object}
     * @memberof PendingTransactionResponse
     */
    'txn': object;
    /**
     * Rewards in microalgos applied to the sender account.
     * @type {number}
     * @memberof PendingTransactionResponse
     */
    'sender-rewards'?: number;
    /**
     * \\[ld\\] Local state key/value changes for the application being executed by this transaction.
     * @type {Array<AccountStateDelta>}
     * @memberof PendingTransactionResponse
     */
    'local-state-delta'?: Array<AccountStateDelta>;
    /**
     * The application index if the transaction was found and it created an application.
     * @type {number}
     * @memberof PendingTransactionResponse
     */
    'application-index'?: number;
    /**
     * Closing amount for the transaction.
     * @type {number}
     * @memberof PendingTransactionResponse
     */
    'closing-amount'?: number;
    /**
     * Inner transactions produced by application execution.
     * @type {Array<PendingTransactionResponse>}
     * @memberof PendingTransactionResponse
     */
    'inner-txns'?: Array<PendingTransactionResponse>;
    /**
     * The number of the asset\'s unit that were transferred to the close-to address.
     * @type {number}
     * @memberof PendingTransactionResponse
     */
    'asset-closing-amount'?: number;
    /**
     * Rewards in microalgos applied to the close remainder to account.
     * @type {number}
     * @memberof PendingTransactionResponse
     */
    'close-rewards'?: number;
    /**
     * \\[lg\\] Logs for the application being executed by this transaction.
     * @type {Array<string>}
     * @memberof PendingTransactionResponse
     */
    'logs'?: Array<string>;
    /**
     * Application state delta.
     * @type {Array<EvalDeltaKeyValue>}
     * @memberof PendingTransactionResponse
     */
    'global-state-delta'?: Array<EvalDeltaKeyValue>;
}
/**
 * PendingTransactions is an array of signed transactions exactly as they were submitted.
 * @export
 * @interface PendingTransactionsResponse
 */
export interface PendingTransactionsResponse {
    /**
     * An array of signed transaction objects.
     * @type {Array<object>}
     * @memberof PendingTransactionsResponse
     */
    'top-transactions': Array<object>;
    /**
     * Total number of transactions in the pool.
     * @type {number}
     * @memberof PendingTransactionsResponse
     */
    'total-transactions': number;
}
/**
 * Supply represents the current supply of MicroAlgos in the system
 * @export
 * @interface SupplyResponse
 */
export interface SupplyResponse {
    /**
     * OnlineMoney
     * @type {number}
     * @memberof SupplyResponse
     */
    'online-money': number;
    /**
     * TotalMoney
     * @type {number}
     * @memberof SupplyResponse
     */
    'total-money': number;
    /**
     * Round
     * @type {number}
     * @memberof SupplyResponse
     */
    'current_round': number;
}
/**
 * Represents a key-value pair in an application store.
 * @export
 * @interface TealKeyValue
 */
export interface TealKeyValue {
    /**
     * 
     * @type {TealValue}
     * @memberof TealKeyValue
     */
    'value': TealValue;
    /**
     * 
     * @type {string}
     * @memberof TealKeyValue
     */
    'key': string;
}
/**
 * Represents a TEAL value.
 * @export
 * @interface TealValue
 */
export interface TealValue {
    /**
     * \\[tb\\] bytes value.
     * @type {string}
     * @memberof TealValue
     */
    'bytes': string;
    /**
     * \\[tt\\] value type. Value `1` refers to **bytes**, value `2` refers to **uint**
     * @type {number}
     * @memberof TealValue
     */
    'type': number;
    /**
     * \\[ui\\] uint value.
     * @type {number}
     * @memberof TealValue
     */
    'uint': number;
}
/**
 * TransactionParams contains the parameters that help a client construct a new transaction.
 * @export
 * @interface TransactionsParametersResponse
 */
export interface TransactionsParametersResponse {
    /**
     * GenesisHash is the hash of the genesis block.
     * @type {string}
     * @memberof TransactionsParametersResponse
     */
    'genesis-hash': string;
    /**
     * The minimum transaction fee (not per byte) required for the txn to validate for the current network protocol.
     * @type {number}
     * @memberof TransactionsParametersResponse
     */
    'min-fee': number;
    /**
     * ConsensusVersion indicates the consensus protocol version as of LastRound.
     * @type {string}
     * @memberof TransactionsParametersResponse
     */
    'consensus-version': string;
    /**
     * Fee is the suggested transaction fee Fee is in units of micro-Algos per byte. Fee may fall to zero but transactions must still have a fee of at least MinTxnFee for the current network protocol.
     * @type {number}
     * @memberof TransactionsParametersResponse
     */
    'fee': number;
    /**
     * GenesisID is an ID listed in the genesis block.
     * @type {string}
     * @memberof TransactionsParametersResponse
     */
    'genesis-id': string;
    /**
     * LastRound indicates the last round seen
     * @type {number}
     * @memberof TransactionsParametersResponse
     */
    'last-round': number;
}
/**
 * 
 * @export
 * @interface TxResponse
 */
export interface TxResponse {
    /**
     * encoding of the transaction hash.
     * @type {string}
     * @memberof TxResponse
     */
    'txId': string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {string} address 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountApplicationInformation: async (applicationId: string, address: string, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('accountApplicationInformation', 'applicationId', applicationId)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('accountApplicationInformation', 'address', address)
            const localVarPath = `/v2/accounts/{address}/applications/{application-id}`
                .replace(`{${"application-id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assetId 
         * @param {string} address 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAssetInformation: async (assetId: string, address: string, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('accountAssetInformation', 'assetId', assetId)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('accountAssetInformation', 'address', address)
            const localVarPath = `/v2/accounts/{address}/assets/{asset-id}`
                .replace(`{${"asset-id"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} address 
         * @param {string} [exclude] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountInformation: async (address: string, exclude?: string, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('accountInformation', 'address', address)
            const localVarPath = `/v2/accounts/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (exclude !== undefined) {
                localVarQueryParameter['exclude'] = exclude;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        genesisOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/genesis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationBoxByName: async (applicationId: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationBoxByName', 'applicationId', applicationId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getApplicationBoxByName', 'name', name)
            const localVarPath = `/v2/applications/{application-id}/box`
                .replace(`{${"application-id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [max] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationBoxes: async (applicationId: string, max?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationBoxes', 'applicationId', applicationId)
            const localVarPath = `/v2/applications/{application-id}/boxes`
                .replace(`{${"application-id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationByID: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationByID', 'applicationId', applicationId)
            const localVarPath = `/v2/applications/{application-id}`
                .replace(`{${"application-id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetByID: async (assetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getAssetByID', 'assetId', assetId)
            const localVarPath = `/v2/assets/{asset-id}`
                .replace(`{${"asset-id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} round 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock: async (round: string, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'round' is not null or undefined
            assertParamExists('getBlock', 'round', round)
            const localVarPath = `/v2/blocks/{round}`
                .replace(`{${"round"}}`, encodeURIComponent(String(round)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockHash: async (round: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'round' is not null or undefined
            assertParamExists('getBlockHash', 'round', round)
            const localVarPath = `/v2/blocks/{round}/hash`
                .replace(`{${"round"}}`, encodeURIComponent(String(round)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenesis: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/genesis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLightBlockHeaderProof: async (round: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'round' is not null or undefined
            assertParamExists('getLightBlockHeaderProof', 'round', round)
            const localVarPath = `/v2/blocks/{round}/lightheader/proof`
                .replace(`{${"round"}}`, encodeURIComponent(String(round)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [max] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingTransactions: async (max?: string, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/transactions/pending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} address 
         * @param {string} [max] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingTransactionsByAddress: async (address: string, max?: string, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getPendingTransactionsByAddress', 'address', address)
            const localVarPath = `/v2/accounts/{address}/transactions/pending`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStateProof: async (round: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'round' is not null or undefined
            assertParamExists('getStateProof', 'round', round)
            const localVarPath = `/v2/stateproofs/{round}`
                .replace(`{${"round"}}`, encodeURIComponent(String(round)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupply: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/ledger/supply`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} txid 
         * @param {string} round 
         * @param {string} [hashtype] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionProof: async (txid: string, round: string, hashtype?: string, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txid' is not null or undefined
            assertParamExists('getTransactionProof', 'txid', txid)
            // verify required parameter 'round' is not null or undefined
            assertParamExists('getTransactionProof', 'round', round)
            const localVarPath = `/v2/blocks/{round}/transactions/{txid}/proof`
                .replace(`{${"txid"}}`, encodeURIComponent(String(txid)))
                .replace(`{${"round"}}`, encodeURIComponent(String(round)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (hashtype !== undefined) {
                localVarQueryParameter['hashtype'] = hashtype;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} txid 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pendingTransactionInformation: async (txid: string, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txid' is not null or undefined
            assertParamExists('pendingTransactionInformation', 'txid', txid)
            const localVarPath = `/v2/transactions/pending/{txid}`
                .replace(`{${"txid"}}`, encodeURIComponent(String(txid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contentType 
         * @param {File} rawTransaction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rawTransaction: async (contentType: string, rawTransaction: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('rawTransaction', 'contentType', contentType)
            // verify required parameter 'rawTransaction' is not null or undefined
            assertParamExists('rawTransaction', 'rawTransaction', rawTransaction)
            const localVarPath = `/v2/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rawTransaction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contentType 
         * @param {File} rawTransaction 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateTransaction: async (contentType: string, rawTransaction: File, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('simulateTransaction', 'contentType', contentType)
            // verify required parameter 'rawTransaction' is not null or undefined
            assertParamExists('simulateTransaction', 'rawTransaction', rawTransaction)
            const localVarPath = `/v2/transactions/simulate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rawTransaction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swaggerJSON: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/swagger.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swaggerJsonOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/swagger.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {File} mODELe34253 
         * @param {string} [sourcemap] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tealCompile: async (mODELe34253: File, sourcemap?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mODELe34253' is not null or undefined
            assertParamExists('tealCompile', 'mODELe34253', mODELe34253)
            const localVarPath = `/v2/teal/compile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (sourcemap !== undefined) {
                localVarQueryParameter['sourcemap'] = sourcemap;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mODELe34253, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contentType 
         * @param {string} mODEL0c300b 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tealDisassemble: async (contentType: string, mODEL0c300b: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('tealDisassemble', 'contentType', contentType)
            // verify required parameter 'mODEL0c300b' is not null or undefined
            assertParamExists('tealDisassemble', 'mODEL0c300b', mODEL0c300b)
            const localVarPath = `/v2/teal/disassemble`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mODEL0c300b, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DryrunRequest} dryrunRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tealDryrun: async (dryrunRequest: DryrunRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dryrunRequest' is not null or undefined
            assertParamExists('tealDryrun', 'dryrunRequest', dryrunRequest)
            const localVarPath = `/v2/teal/dryrun`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dryrunRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/transactions/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsAddressApplicationsApplicationIdOptions: async (applicationId: string, address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('v2AccountsAddressApplicationsApplicationIdOptions', 'applicationId', applicationId)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('v2AccountsAddressApplicationsApplicationIdOptions', 'address', address)
            const localVarPath = `/v2/accounts/{address}/applications/{application-id}`
                .replace(`{${"application-id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assetId 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsAddressAssetsAssetIdOptions: async (assetId: string, address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('v2AccountsAddressAssetsAssetIdOptions', 'assetId', assetId)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('v2AccountsAddressAssetsAssetIdOptions', 'address', address)
            const localVarPath = `/v2/accounts/{address}/assets/{asset-id}`
                .replace(`{${"asset-id"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsAddressOptions: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('v2AccountsAddressOptions', 'address', address)
            const localVarPath = `/v2/accounts/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsAddressTransactionsPendingOptions: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('v2AccountsAddressTransactionsPendingOptions', 'address', address)
            const localVarPath = `/v2/accounts/{address}/transactions/pending`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ApplicationsApplicationIdBoxOptions: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('v2ApplicationsApplicationIdBoxOptions', 'applicationId', applicationId)
            const localVarPath = `/v2/applications/{application-id}/box`
                .replace(`{${"application-id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ApplicationsApplicationIdBoxesOptions: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('v2ApplicationsApplicationIdBoxesOptions', 'applicationId', applicationId)
            const localVarPath = `/v2/applications/{application-id}/boxes`
                .replace(`{${"application-id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ApplicationsApplicationIdOptions: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('v2ApplicationsApplicationIdOptions', 'applicationId', applicationId)
            const localVarPath = `/v2/applications/{application-id}`
                .replace(`{${"application-id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AssetsAssetIdOptions: async (assetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('v2AssetsAssetIdOptions', 'assetId', assetId)
            const localVarPath = `/v2/assets/{asset-id}`
                .replace(`{${"asset-id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2BlocksRoundHashOptions: async (round: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'round' is not null or undefined
            assertParamExists('v2BlocksRoundHashOptions', 'round', round)
            const localVarPath = `/v2/blocks/{round}/hash`
                .replace(`{${"round"}}`, encodeURIComponent(String(round)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2BlocksRoundLightheaderProofOptions: async (round: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'round' is not null or undefined
            assertParamExists('v2BlocksRoundLightheaderProofOptions', 'round', round)
            const localVarPath = `/v2/blocks/{round}/lightheader/proof`
                .replace(`{${"round"}}`, encodeURIComponent(String(round)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2BlocksRoundOptions: async (round: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'round' is not null or undefined
            assertParamExists('v2BlocksRoundOptions', 'round', round)
            const localVarPath = `/v2/blocks/{round}`
                .replace(`{${"round"}}`, encodeURIComponent(String(round)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} txid 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2BlocksRoundTransactionsTxidProofOptions: async (txid: string, round: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txid' is not null or undefined
            assertParamExists('v2BlocksRoundTransactionsTxidProofOptions', 'txid', txid)
            // verify required parameter 'round' is not null or undefined
            assertParamExists('v2BlocksRoundTransactionsTxidProofOptions', 'round', round)
            const localVarPath = `/v2/blocks/{round}/transactions/{txid}/proof`
                .replace(`{${"txid"}}`, encodeURIComponent(String(txid)))
                .replace(`{${"round"}}`, encodeURIComponent(String(round)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2LedgerSupplyOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/ledger/supply`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StateproofsRoundOptions: async (round: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'round' is not null or undefined
            assertParamExists('v2StateproofsRoundOptions', 'round', round)
            const localVarPath = `/v2/stateproofs/{round}`
                .replace(`{${"round"}}`, encodeURIComponent(String(round)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StatusOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StatusWaitForBlockAfterRoundOptions: async (round: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'round' is not null or undefined
            assertParamExists('v2StatusWaitForBlockAfterRoundOptions', 'round', round)
            const localVarPath = `/v2/status/wait-for-block-after/{round}`
                .replace(`{${"round"}}`, encodeURIComponent(String(round)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TealCompileOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/teal/compile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TealDisassembleOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/teal/disassemble`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TealDryrunOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/teal/dryrun`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TransactionsOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TransactionsParamsOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/transactions/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TransactionsPendingOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/transactions/pending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} txid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TransactionsPendingTxidOptions: async (txid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txid' is not null or undefined
            assertParamExists('v2TransactionsPendingTxidOptions', 'txid', txid)
            const localVarPath = `/v2/transactions/pending/{txid}`
                .replace(`{${"txid"}}`, encodeURIComponent(String(txid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TransactionsSimulateOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/transactions/simulate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionsOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForBlock: async (round: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'round' is not null or undefined
            assertParamExists('waitForBlock', 'round', round)
            const localVarPath = `/v2/status/wait-for-block-after/{round}`
                .replace(`{${"round"}}`, encodeURIComponent(String(round)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {string} address 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountApplicationInformation(applicationId: string, address: string, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountApplicationInformation(applicationId, address, format, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} assetId 
         * @param {string} address 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAssetInformation(assetId: string, address: string, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountAssetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountAssetInformation(assetId, address, format, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} address 
         * @param {string} [exclude] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountInformation(address: string, exclude?: string, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountInformation(address, exclude, format, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async genesisOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.genesisOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationBoxByName(applicationId: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoxResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationBoxByName(applicationId, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [max] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationBoxes(applicationId: string, max?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoxesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationBoxes(applicationId, max, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationByID(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationByID(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetByID(assetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetByID(assetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} round 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlock(round: string, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlock(round, format, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockHash(round: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockHashResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockHash(round, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGenesis(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGenesis(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLightBlockHeaderProof(round: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LightBlockHeaderProofResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLightBlockHeaderProof(round, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [max] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPendingTransactions(max?: string, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PendingTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPendingTransactions(max, format, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} address 
         * @param {string} [max] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPendingTransactionsByAddress(address: string, max?: string, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPendingTransactionsByAddress(address, max, format, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStateProof(round: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStateProof(round, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodeStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSupply(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSupply(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} txid 
         * @param {string} round 
         * @param {string} [hashtype] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionProof(txid: string, round: string, hashtype?: string, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionProof(txid, round, hashtype, format, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheck(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} txid 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pendingTransactionInformation(txid: string, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PendingTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pendingTransactionInformation(txid, format, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} contentType 
         * @param {File} rawTransaction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rawTransaction(contentType: string, rawTransaction: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rawTransaction(contentType, rawTransaction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} contentType 
         * @param {File} rawTransaction 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulateTransaction(contentType: string, rawTransaction: File, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulateTransaction(contentType, rawTransaction, format, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async swaggerJSON(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.swaggerJSON(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async swaggerJsonOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.swaggerJsonOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {File} mODELe34253 
         * @param {string} [sourcemap] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tealCompile(mODELe34253: File, sourcemap?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tealCompile(mODELe34253, sourcemap, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} contentType 
         * @param {string} mODEL0c300b 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tealDisassemble(contentType: string, mODEL0c300b: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisassembleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tealDisassemble(contentType, mODEL0c300b, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DryrunRequest} dryrunRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tealDryrun(dryrunRequest: DryrunRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DryrunResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tealDryrun(dryrunRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsParametersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AccountsAddressApplicationsApplicationIdOptions(applicationId: string, address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AccountsAddressApplicationsApplicationIdOptions(applicationId, address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} assetId 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AccountsAddressAssetsAssetIdOptions(assetId: string, address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AccountsAddressAssetsAssetIdOptions(assetId, address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AccountsAddressOptions(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AccountsAddressOptions(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AccountsAddressTransactionsPendingOptions(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AccountsAddressTransactionsPendingOptions(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2ApplicationsApplicationIdBoxOptions(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2ApplicationsApplicationIdBoxOptions(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2ApplicationsApplicationIdBoxesOptions(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2ApplicationsApplicationIdBoxesOptions(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2ApplicationsApplicationIdOptions(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2ApplicationsApplicationIdOptions(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AssetsAssetIdOptions(assetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AssetsAssetIdOptions(assetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2BlocksRoundHashOptions(round: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2BlocksRoundHashOptions(round, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2BlocksRoundLightheaderProofOptions(round: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2BlocksRoundLightheaderProofOptions(round, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2BlocksRoundOptions(round: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2BlocksRoundOptions(round, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} txid 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2BlocksRoundTransactionsTxidProofOptions(txid: string, round: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2BlocksRoundTransactionsTxidProofOptions(txid, round, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2LedgerSupplyOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2LedgerSupplyOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2StateproofsRoundOptions(round: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2StateproofsRoundOptions(round, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2StatusOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2StatusOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2StatusWaitForBlockAfterRoundOptions(round: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2StatusWaitForBlockAfterRoundOptions(round, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2TealCompileOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2TealCompileOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2TealDisassembleOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2TealDisassembleOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2TealDryrunOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2TealDryrunOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2TransactionsOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2TransactionsOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2TransactionsParamsOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2TransactionsParamsOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2TransactionsPendingOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2TransactionsPendingOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} txid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2TransactionsPendingTxidOptions(txid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2TransactionsPendingTxidOptions(txid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2TransactionsSimulateOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2TransactionsSimulateOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async versionsOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.versionsOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitForBlock(round: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodeStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.waitForBlock(round, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {string} address 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountApplicationInformation(applicationId: string, address: string, format?: string, options?: any): AxiosPromise<AccountApplicationResponse> {
            return localVarFp.accountApplicationInformation(applicationId, address, format, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} assetId 
         * @param {string} address 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAssetInformation(assetId: string, address: string, format?: string, options?: any): AxiosPromise<AccountAssetResponse> {
            return localVarFp.accountAssetInformation(assetId, address, format, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} address 
         * @param {string} [exclude] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountInformation(address: string, exclude?: string, format?: string, options?: any): AxiosPromise<Account> {
            return localVarFp.accountInformation(address, exclude, format, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        genesisOptions(options?: any): AxiosPromise<void> {
            return localVarFp.genesisOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationBoxByName(applicationId: string, name: string, options?: any): AxiosPromise<BoxResponse> {
            return localVarFp.getApplicationBoxByName(applicationId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [max] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationBoxes(applicationId: string, max?: string, options?: any): AxiosPromise<BoxesResponse> {
            return localVarFp.getApplicationBoxes(applicationId, max, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationByID(applicationId: string, options?: any): AxiosPromise<ApplicationResponse> {
            return localVarFp.getApplicationByID(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetByID(assetId: string, options?: any): AxiosPromise<AssetResponse> {
            return localVarFp.getAssetByID(assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} round 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock(round: string, format?: string, options?: any): AxiosPromise<BlockResponse> {
            return localVarFp.getBlock(round, format, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockHash(round: string, options?: any): AxiosPromise<BlockHashResponse> {
            return localVarFp.getBlockHash(round, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenesis(options?: any): AxiosPromise<void> {
            return localVarFp.getGenesis(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLightBlockHeaderProof(round: string, options?: any): AxiosPromise<LightBlockHeaderProofResponse> {
            return localVarFp.getLightBlockHeaderProof(round, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [max] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingTransactions(max?: string, format?: string, options?: any): AxiosPromise<PendingTransactionsResponse> {
            return localVarFp.getPendingTransactions(max, format, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} address 
         * @param {string} [max] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingTransactionsByAddress(address: string, max?: string, format?: string, options?: any): AxiosPromise<void> {
            return localVarFp.getPendingTransactionsByAddress(address, max, format, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStateProof(round: string, options?: any): AxiosPromise<object> {
            return localVarFp.getStateProof(round, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any): AxiosPromise<NodeStatusResponse> {
            return localVarFp.getStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupply(options?: any): AxiosPromise<SupplyResponse> {
            return localVarFp.getSupply(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} txid 
         * @param {string} round 
         * @param {string} [hashtype] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionProof(txid: string, round: string, hashtype?: string, format?: string, options?: any): AxiosPromise<object> {
            return localVarFp.getTransactionProof(txid, round, hashtype, format, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: any): AxiosPromise<object> {
            return localVarFp.getVersion(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options?: any): AxiosPromise<void> {
            return localVarFp.healthCheck(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthOptions(options?: any): AxiosPromise<void> {
            return localVarFp.healthOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} txid 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pendingTransactionInformation(txid: string, format?: string, options?: any): AxiosPromise<PendingTransactionResponse> {
            return localVarFp.pendingTransactionInformation(txid, format, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} contentType 
         * @param {File} rawTransaction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rawTransaction(contentType: string, rawTransaction: File, options?: any): AxiosPromise<TxResponse> {
            return localVarFp.rawTransaction(contentType, rawTransaction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} contentType 
         * @param {File} rawTransaction 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateTransaction(contentType: string, rawTransaction: File, format?: string, options?: any): AxiosPromise<void> {
            return localVarFp.simulateTransaction(contentType, rawTransaction, format, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swaggerJSON(options?: any): AxiosPromise<void> {
            return localVarFp.swaggerJSON(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swaggerJsonOptions(options?: any): AxiosPromise<void> {
            return localVarFp.swaggerJsonOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {File} mODELe34253 
         * @param {string} [sourcemap] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tealCompile(mODELe34253: File, sourcemap?: string, options?: any): AxiosPromise<CompileResponse> {
            return localVarFp.tealCompile(mODELe34253, sourcemap, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} contentType 
         * @param {string} mODEL0c300b 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tealDisassemble(contentType: string, mODEL0c300b: string, options?: any): AxiosPromise<DisassembleResponse> {
            return localVarFp.tealDisassemble(contentType, mODEL0c300b, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DryrunRequest} dryrunRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tealDryrun(dryrunRequest: DryrunRequest, options?: any): AxiosPromise<DryrunResponse> {
            return localVarFp.tealDryrun(dryrunRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionParams(options?: any): AxiosPromise<TransactionsParametersResponse> {
            return localVarFp.transactionParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsAddressApplicationsApplicationIdOptions(applicationId: string, address: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2AccountsAddressApplicationsApplicationIdOptions(applicationId, address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} assetId 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsAddressAssetsAssetIdOptions(assetId: string, address: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2AccountsAddressAssetsAssetIdOptions(assetId, address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsAddressOptions(address: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2AccountsAddressOptions(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsAddressTransactionsPendingOptions(address: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2AccountsAddressTransactionsPendingOptions(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ApplicationsApplicationIdBoxOptions(applicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2ApplicationsApplicationIdBoxOptions(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ApplicationsApplicationIdBoxesOptions(applicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2ApplicationsApplicationIdBoxesOptions(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ApplicationsApplicationIdOptions(applicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2ApplicationsApplicationIdOptions(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AssetsAssetIdOptions(assetId: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2AssetsAssetIdOptions(assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2BlocksRoundHashOptions(round: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2BlocksRoundHashOptions(round, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2BlocksRoundLightheaderProofOptions(round: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2BlocksRoundLightheaderProofOptions(round, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2BlocksRoundOptions(round: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2BlocksRoundOptions(round, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} txid 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2BlocksRoundTransactionsTxidProofOptions(txid: string, round: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2BlocksRoundTransactionsTxidProofOptions(txid, round, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2LedgerSupplyOptions(options?: any): AxiosPromise<void> {
            return localVarFp.v2LedgerSupplyOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StateproofsRoundOptions(round: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2StateproofsRoundOptions(round, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StatusOptions(options?: any): AxiosPromise<void> {
            return localVarFp.v2StatusOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StatusWaitForBlockAfterRoundOptions(round: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2StatusWaitForBlockAfterRoundOptions(round, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TealCompileOptions(options?: any): AxiosPromise<void> {
            return localVarFp.v2TealCompileOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TealDisassembleOptions(options?: any): AxiosPromise<void> {
            return localVarFp.v2TealDisassembleOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TealDryrunOptions(options?: any): AxiosPromise<void> {
            return localVarFp.v2TealDryrunOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TransactionsOptions(options?: any): AxiosPromise<void> {
            return localVarFp.v2TransactionsOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TransactionsParamsOptions(options?: any): AxiosPromise<void> {
            return localVarFp.v2TransactionsParamsOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TransactionsPendingOptions(options?: any): AxiosPromise<void> {
            return localVarFp.v2TransactionsPendingOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} txid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TransactionsPendingTxidOptions(txid: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2TransactionsPendingTxidOptions(txid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TransactionsSimulateOptions(options?: any): AxiosPromise<void> {
            return localVarFp.v2TransactionsSimulateOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionsOptions(options?: any): AxiosPromise<void> {
            return localVarFp.versionsOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} round 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForBlock(round: string, options?: any): AxiosPromise<NodeStatusResponse> {
            return localVarFp.waitForBlock(round, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
    /**
     * 
     * @param {string} applicationId 
     * @param {string} address 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    accountApplicationInformation(applicationId: string, address: string, format?: string, options?: AxiosRequestConfig): AxiosPromise<AccountApplicationResponse>;

    /**
     * 
     * @param {string} assetId 
     * @param {string} address 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    accountAssetInformation(assetId: string, address: string, format?: string, options?: AxiosRequestConfig): AxiosPromise<AccountAssetResponse>;

    /**
     * 
     * @param {string} address 
     * @param {string} [exclude] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    accountInformation(address: string, exclude?: string, format?: string, options?: AxiosRequestConfig): AxiosPromise<Account>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    genesisOptions(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getApplicationBoxByName(applicationId: string, name: string, options?: AxiosRequestConfig): AxiosPromise<BoxResponse>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} [max] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getApplicationBoxes(applicationId: string, max?: string, options?: AxiosRequestConfig): AxiosPromise<BoxesResponse>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getApplicationByID(applicationId: string, options?: AxiosRequestConfig): AxiosPromise<ApplicationResponse>;

    /**
     * 
     * @param {string} assetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getAssetByID(assetId: string, options?: AxiosRequestConfig): AxiosPromise<AssetResponse>;

    /**
     * 
     * @param {string} round 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getBlock(round: string, format?: string, options?: AxiosRequestConfig): AxiosPromise<BlockResponse>;

    /**
     * 
     * @param {string} round 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getBlockHash(round: string, options?: AxiosRequestConfig): AxiosPromise<BlockHashResponse>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getGenesis(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} round 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getLightBlockHeaderProof(round: string, options?: AxiosRequestConfig): AxiosPromise<LightBlockHeaderProofResponse>;

    /**
     * 
     * @param {string} [max] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getPendingTransactions(max?: string, format?: string, options?: AxiosRequestConfig): AxiosPromise<PendingTransactionsResponse>;

    /**
     * 
     * @param {string} address 
     * @param {string} [max] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getPendingTransactionsByAddress(address: string, max?: string, format?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} round 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getStateProof(round: string, options?: AxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getStatus(options?: AxiosRequestConfig): AxiosPromise<NodeStatusResponse>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getSupply(options?: AxiosRequestConfig): AxiosPromise<SupplyResponse>;

    /**
     * 
     * @param {string} txid 
     * @param {string} round 
     * @param {string} [hashtype] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getTransactionProof(txid: string, round: string, hashtype?: string, format?: string, options?: AxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getVersion(options?: AxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    healthCheck(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    healthOptions(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} txid 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    pendingTransactionInformation(txid: string, format?: string, options?: AxiosRequestConfig): AxiosPromise<PendingTransactionResponse>;

    /**
     * 
     * @param {string} contentType 
     * @param {File} rawTransaction 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    rawTransaction(contentType: string, rawTransaction: File, options?: AxiosRequestConfig): AxiosPromise<TxResponse>;

    /**
     * 
     * @param {string} contentType 
     * @param {File} rawTransaction 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    simulateTransaction(contentType: string, rawTransaction: File, format?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    swaggerJSON(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    swaggerJsonOptions(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {File} mODELe34253 
     * @param {string} [sourcemap] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    tealCompile(mODELe34253: File, sourcemap?: string, options?: AxiosRequestConfig): AxiosPromise<CompileResponse>;

    /**
     * 
     * @param {string} contentType 
     * @param {string} mODEL0c300b 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    tealDisassemble(contentType: string, mODEL0c300b: string, options?: AxiosRequestConfig): AxiosPromise<DisassembleResponse>;

    /**
     * 
     * @param {DryrunRequest} dryrunRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    tealDryrun(dryrunRequest: DryrunRequest, options?: AxiosRequestConfig): AxiosPromise<DryrunResponse>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    transactionParams(options?: AxiosRequestConfig): AxiosPromise<TransactionsParametersResponse>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2AccountsAddressApplicationsApplicationIdOptions(applicationId: string, address: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} assetId 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2AccountsAddressAssetsAssetIdOptions(assetId: string, address: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2AccountsAddressOptions(address: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2AccountsAddressTransactionsPendingOptions(address: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2ApplicationsApplicationIdBoxOptions(applicationId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2ApplicationsApplicationIdBoxesOptions(applicationId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2ApplicationsApplicationIdOptions(applicationId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} assetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2AssetsAssetIdOptions(assetId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} round 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2BlocksRoundHashOptions(round: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} round 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2BlocksRoundLightheaderProofOptions(round: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} round 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2BlocksRoundOptions(round: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} txid 
     * @param {string} round 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2BlocksRoundTransactionsTxidProofOptions(txid: string, round: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2LedgerSupplyOptions(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} round 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2StateproofsRoundOptions(round: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2StatusOptions(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} round 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2StatusWaitForBlockAfterRoundOptions(round: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2TealCompileOptions(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2TealDisassembleOptions(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2TealDryrunOptions(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2TransactionsOptions(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2TransactionsParamsOptions(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2TransactionsPendingOptions(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} txid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2TransactionsPendingTxidOptions(txid: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2TransactionsSimulateOptions(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    versionsOptions(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} round 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    waitForBlock(round: string, options?: AxiosRequestConfig): AxiosPromise<NodeStatusResponse>;

}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * 
     * @param {string} applicationId 
     * @param {string} address 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountApplicationInformation(applicationId: string, address: string, format?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountApplicationInformation(applicationId, address, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} assetId 
     * @param {string} address 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountAssetInformation(assetId: string, address: string, format?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountAssetInformation(assetId, address, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} address 
     * @param {string} [exclude] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountInformation(address: string, exclude?: string, format?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountInformation(address, exclude, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public genesisOptions(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).genesisOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApplicationBoxByName(applicationId: string, name: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApplicationBoxByName(applicationId, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} [max] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApplicationBoxes(applicationId: string, max?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApplicationBoxes(applicationId, max, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApplicationByID(applicationId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApplicationByID(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} assetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAssetByID(assetId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAssetByID(assetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} round 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBlock(round: string, format?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBlock(round, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} round 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBlockHash(round: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBlockHash(round, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGenesis(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGenesis(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} round 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLightBlockHeaderProof(round: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLightBlockHeaderProof(round, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [max] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPendingTransactions(max?: string, format?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPendingTransactions(max, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} address 
     * @param {string} [max] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPendingTransactionsByAddress(address: string, max?: string, format?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPendingTransactionsByAddress(address, max, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} round 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStateProof(round: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStateProof(round, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStatus(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSupply(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSupply(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} txid 
     * @param {string} round 
     * @param {string} [hashtype] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTransactionProof(txid: string, round: string, hashtype?: string, format?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTransactionProof(txid, round, hashtype, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getVersion(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getVersion(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public healthCheck(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public healthOptions(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} txid 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public pendingTransactionInformation(txid: string, format?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).pendingTransactionInformation(txid, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} contentType 
     * @param {File} rawTransaction 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rawTransaction(contentType: string, rawTransaction: File, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rawTransaction(contentType, rawTransaction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} contentType 
     * @param {File} rawTransaction 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public simulateTransaction(contentType: string, rawTransaction: File, format?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).simulateTransaction(contentType, rawTransaction, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public swaggerJSON(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).swaggerJSON(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public swaggerJsonOptions(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).swaggerJsonOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {File} mODELe34253 
     * @param {string} [sourcemap] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tealCompile(mODELe34253: File, sourcemap?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tealCompile(mODELe34253, sourcemap, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} contentType 
     * @param {string} mODEL0c300b 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tealDisassemble(contentType: string, mODEL0c300b: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tealDisassemble(contentType, mODEL0c300b, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DryrunRequest} dryrunRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tealDryrun(dryrunRequest: DryrunRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tealDryrun(dryrunRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionParams(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).transactionParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AccountsAddressApplicationsApplicationIdOptions(applicationId: string, address: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AccountsAddressApplicationsApplicationIdOptions(applicationId, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} assetId 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AccountsAddressAssetsAssetIdOptions(assetId: string, address: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AccountsAddressAssetsAssetIdOptions(assetId, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AccountsAddressOptions(address: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AccountsAddressOptions(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AccountsAddressTransactionsPendingOptions(address: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AccountsAddressTransactionsPendingOptions(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2ApplicationsApplicationIdBoxOptions(applicationId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2ApplicationsApplicationIdBoxOptions(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2ApplicationsApplicationIdBoxesOptions(applicationId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2ApplicationsApplicationIdBoxesOptions(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2ApplicationsApplicationIdOptions(applicationId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2ApplicationsApplicationIdOptions(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} assetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AssetsAssetIdOptions(assetId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AssetsAssetIdOptions(assetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} round 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2BlocksRoundHashOptions(round: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2BlocksRoundHashOptions(round, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} round 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2BlocksRoundLightheaderProofOptions(round: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2BlocksRoundLightheaderProofOptions(round, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} round 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2BlocksRoundOptions(round: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2BlocksRoundOptions(round, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} txid 
     * @param {string} round 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2BlocksRoundTransactionsTxidProofOptions(txid: string, round: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2BlocksRoundTransactionsTxidProofOptions(txid, round, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2LedgerSupplyOptions(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2LedgerSupplyOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} round 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2StateproofsRoundOptions(round: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2StateproofsRoundOptions(round, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2StatusOptions(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2StatusOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} round 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2StatusWaitForBlockAfterRoundOptions(round: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2StatusWaitForBlockAfterRoundOptions(round, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2TealCompileOptions(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2TealCompileOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2TealDisassembleOptions(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2TealDisassembleOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2TealDryrunOptions(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2TealDryrunOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2TransactionsOptions(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2TransactionsOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2TransactionsParamsOptions(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2TransactionsParamsOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2TransactionsPendingOptions(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2TransactionsPendingOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} txid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2TransactionsPendingTxidOptions(txid: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2TransactionsPendingTxidOptions(txid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2TransactionsSimulateOptions(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2TransactionsSimulateOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public versionsOptions(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).versionsOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} round 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public waitForBlock(round: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).waitForBlock(round, options).then((request) => request(this.axios, this.basePath));
    }
}


