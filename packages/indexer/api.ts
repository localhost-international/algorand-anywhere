/* tslint:disable */
/* eslint-disable */
/**
 * Indexer Mainnet v2 API
 * Algorand ledger analytics API.
 *
 * The version of the OpenAPI document: 2.15.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * Account information at a given round.  Definition: data/basics/userBalance.go : AccountData 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {AccountParticipation}
     * @memberof Account
     */
    'participation'?: AccountParticipation;
    /**
     * 
     * @type {ApplicationStateSchema}
     * @memberof Account
     */
    'apps-total-schema'?: ApplicationStateSchema;
    /**
     * The count of all applications that have been opted in, equivalent to the count of application local data (AppLocalState objects) stored in this account.
     * @type {number}
     * @memberof Account
     */
    'total-apps-opted-in': number;
    /**
     * Round during which this account was most recently closed.
     * @type {number}
     * @memberof Account
     */
    'closed-at-round'?: number;
    /**
     * The count of all apps (AppParams objects) created by this account.
     * @type {number}
     * @memberof Account
     */
    'total-created-apps': number;
    /**
     * \\[asset\\] assets held by this account.  Note the raw object uses `map[int] -> AssetHolding` for this type.
     * @type {Array<AssetHolding>}
     * @memberof Account
     */
    'assets'?: Array<AssetHolding>;
    /**
     * The count of all assets (AssetParams objects) created by this account.
     * @type {number}
     * @memberof Account
     */
    'total-created-assets': number;
    /**
     * For app-accounts only. The total number of boxes which belong to the associated application.
     * @type {number}
     * @memberof Account
     */
    'total-boxes': number;
    /**
     * \\[algo\\] total number of MicroAlgos in the account
     * @type {number}
     * @memberof Account
     */
    'amount': number;
    /**
     * the account public key
     * @type {string}
     * @memberof Account
     */
    'address': string;
    /**
     * Round during which this account first appeared in a transaction.
     * @type {number}
     * @memberof Account
     */
    'created-at-round'?: number;
    /**
     * \\[appl\\] applications local data stored in this account. Note the raw object uses `map[int] -> AppLocalState` for this type.
     * @type {Array<ApplicationLocalState>}
     * @memberof Account
     */
    'apps-local-state'?: Array<ApplicationLocalState>;
    /**
     * \\[apar\\] parameters of assets created by this account.   Note: the raw account uses `map[int] -> Asset` for this type.
     * @type {Array<Asset>}
     * @memberof Account
     */
    'created-assets'?: Array<Asset>;
    /**
     * \\[ebase\\] used as part of the rewards computation. Only applicable to accounts which are participating.
     * @type {number}
     * @memberof Account
     */
    'reward-base'?: number;
    /**
     * amount of MicroAlgos of pending rewards in this account.
     * @type {number}
     * @memberof Account
     */
    'pending-rewards': number;
    /**
     * \\[appp\\] parameters of applications created by this account including app global data.  Note: the raw account uses `map[int] -> AppParams` for this type.
     * @type {Array<Application>}
     * @memberof Account
     */
    'created-apps'?: Array<Application>;
    /**
     * The count of all assets that have been opted in, equivalent to the count of AssetHolding objects held by this account.
     * @type {number}
     * @memberof Account
     */
    'total-assets-opted-in': number;
    /**
     * For app-accounts only. The total number of bytes allocated for the keys and values of boxes which belong to the associated application.
     * @type {number}
     * @memberof Account
     */
    'total-box-bytes': number;
    /**
     * Whether or not this account is currently closed.
     * @type {boolean}
     * @memberof Account
     */
    'deleted'?: boolean;
    /**
     * The round for which this information is relevant.
     * @type {number}
     * @memberof Account
     */
    'round': number;
    /**
     * specifies the amount of MicroAlgos in the account, without the pending rewards.
     * @type {number}
     * @memberof Account
     */
    'amount-without-pending-rewards': number;
    /**
     * \\[spend\\] the address against which signing should be checked. If empty, the address of the current account is used. This field can be updated in any transaction by setting the RekeyTo field.
     * @type {string}
     * @memberof Account
     */
    'auth-addr'?: string;
    /**
     * \\[ern\\] total rewards of MicroAlgos the account has received, including pending rewards.
     * @type {number}
     * @memberof Account
     */
    'rewards': number;
    /**
     * \\[onl\\] delegation status of the account\'s MicroAlgos * Offline - indicates that the associated account is delegated. *  Online  - indicates that the associated account used as part of the delegation pool. *   NotParticipating - indicates that the associated account is neither a delegator nor a delegate.
     * @type {string}
     * @memberof Account
     */
    'status': string;
    /**
     * Indicates what type of signature is used by this account, must be one of: * sig * msig * lsig * or null if unknown
     * @type {string}
     * @memberof Account
     */
    'sig-type'?: AccountSigTypeEnum;
}

export const AccountSigTypeEnum = {
    Sig: 'sig',
    Msig: 'msig',
    Lsig: 'lsig'
} as const;

export type AccountSigTypeEnum = typeof AccountSigTypeEnum[keyof typeof AccountSigTypeEnum];

/**
 * AccountParticipation describes the parameters used by this account in consensus protocol.
 * @export
 * @interface AccountParticipation
 */
export interface AccountParticipation {
    /**
     * \\[stprf\\] Root of the state proof key (if any)
     * @type {string}
     * @memberof AccountParticipation
     */
    'state-proof-key'?: string;
    /**
     * \\[vote\\] root participation public key (if any) currently registered for this round.
     * @type {string}
     * @memberof AccountParticipation
     */
    'vote-participation-key': string;
    /**
     * \\[voteLst\\] Last round for which this participation is valid.
     * @type {number}
     * @memberof AccountParticipation
     */
    'vote-last-valid': number;
    /**
     * \\[voteKD\\] Number of subkeys in each batch of participation keys.
     * @type {number}
     * @memberof AccountParticipation
     */
    'vote-key-dilution': number;
    /**
     * \\[voteFst\\] First round for which this participation is valid.
     * @type {number}
     * @memberof AccountParticipation
     */
    'vote-first-valid': number;
    /**
     * \\[sel\\] Selection public key (if any) currently registered for this round.
     * @type {string}
     * @memberof AccountParticipation
     */
    'selection-participation-key': string;
}
/**
 * 
 * @export
 * @interface AccountResponse
 */
export interface AccountResponse {
    /**
     * Round at which the results were computed.
     * @type {number}
     * @memberof AccountResponse
     */
    'current-round': number;
    /**
     * 
     * @type {Account}
     * @memberof AccountResponse
     */
    'account': Account;
}
/**
 * Application state delta.
 * @export
 * @interface AccountStateDelta
 */
export interface AccountStateDelta {
    /**
     * 
     * @type {string}
     * @memberof AccountStateDelta
     */
    'address': string;
    /**
     * Application state delta.
     * @type {Array<EvalDeltaKeyValue>}
     * @memberof AccountStateDelta
     */
    'delta': Array<EvalDeltaKeyValue>;
}
/**
 * 
 * @export
 * @interface AccountsResponse
 */
export interface AccountsResponse {
    /**
     * Used for pagination, when making another request provide this token with the next parameter.
     * @type {string}
     * @memberof AccountsResponse
     */
    'next-token'?: string;
    /**
     * Round at which the results were computed.
     * @type {number}
     * @memberof AccountsResponse
     */
    'current-round': number;
    /**
     * 
     * @type {Array<Account>}
     * @memberof AccountsResponse
     */
    'accounts': Array<Account>;
}
/**
 * An error response with optional data field.
 * @export
 * @interface ApigatewayError
 */
export interface ApigatewayError {
    /**
     * 
     * @type {string}
     * @memberof ApigatewayError
     */
    'data'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApigatewayError
     */
    'message': string;
}
/**
 * Application index and its parameters
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * Round when this application was deleted.
     * @type {number}
     * @memberof Application
     */
    'deleted-at-round'?: number;
    /**
     * Whether or not this application is currently deleted.
     * @type {boolean}
     * @memberof Application
     */
    'deleted'?: boolean;
    /**
     * Round when this application was created.
     * @type {number}
     * @memberof Application
     */
    'created-at-round'?: number;
    /**
     * \\[appidx\\] application index.
     * @type {number}
     * @memberof Application
     */
    'id': number;
    /**
     * 
     * @type {ApplicationParams}
     * @memberof Application
     */
    'params': ApplicationParams;
}
/**
 * Stores local state associated with an application.
 * @export
 * @interface ApplicationLocalState
 */
export interface ApplicationLocalState {
    /**
     * 
     * @type {ApplicationStateSchema}
     * @memberof ApplicationLocalState
     */
    'schema': ApplicationStateSchema;
    /**
     * Whether or not the application local state is currently deleted from its account.
     * @type {boolean}
     * @memberof ApplicationLocalState
     */
    'deleted'?: boolean;
    /**
     * Round when account closed out of the application.
     * @type {number}
     * @memberof ApplicationLocalState
     */
    'closed-out-at-round'?: number;
    /**
     * Represents a key-value store for use in an application.
     * @type {Array<TealKeyValue>}
     * @memberof ApplicationLocalState
     */
    'key-value'?: Array<TealKeyValue>;
    /**
     * Round when the account opted into the application.
     * @type {number}
     * @memberof ApplicationLocalState
     */
    'opted-in-at-round'?: number;
    /**
     * The application which this local state is for.
     * @type {number}
     * @memberof ApplicationLocalState
     */
    'id': number;
}
/**
 * Stores the global information associated with an application.
 * @export
 * @interface ApplicationLogData
 */
export interface ApplicationLogData {
    /**
     * Transaction ID
     * @type {string}
     * @memberof ApplicationLogData
     */
    'txid': string;
    /**
     * \\[lg\\] Logs for the application being executed by the transaction.
     * @type {Array<string>}
     * @memberof ApplicationLogData
     */
    'logs': Array<string>;
}
/**
 * (empty)
 * @export
 * @interface ApplicationLogsResponse
 */
export interface ApplicationLogsResponse {
    /**
     * Used for pagination, when making another request provide this token with the next parameter.
     * @type {string}
     * @memberof ApplicationLogsResponse
     */
    'next-token'?: string;
    /**
     * Round at which the results were computed.
     * @type {number}
     * @memberof ApplicationLogsResponse
     */
    'current-round': number;
    /**
     * 
     * @type {Array<ApplicationLogData>}
     * @memberof ApplicationLogsResponse
     */
    'log-data'?: Array<ApplicationLogData>;
    /**
     * \\[appidx\\] application index.
     * @type {number}
     * @memberof ApplicationLogsResponse
     */
    'application-id': number;
}
/**
 * Stores the global information associated with an application.
 * @export
 * @interface ApplicationParams
 */
export interface ApplicationParams {
    /**
     * Represents a key-value store for use in an application.
     * @type {Array<TealKeyValue>}
     * @memberof ApplicationParams
     */
    'global-state'?: Array<TealKeyValue>;
    /**
     * \\[clearp\\] approval program.
     * @type {string}
     * @memberof ApplicationParams
     */
    'clear-state-program': string;
    /**
     * The address that created this application. This is the address where the parameters and global state for this application can be found.
     * @type {string}
     * @memberof ApplicationParams
     */
    'creator'?: string;
    /**
     * 
     * @type {ApplicationStateSchema}
     * @memberof ApplicationParams
     */
    'local-state-schema'?: ApplicationStateSchema;
    /**
     * \\[approv\\] approval program.
     * @type {string}
     * @memberof ApplicationParams
     */
    'approval-program': string;
    /**
     * 
     * @type {ApplicationStateSchema}
     * @memberof ApplicationParams
     */
    'global-state-schema'?: ApplicationStateSchema;
}
/**
 * (empty)
 * @export
 * @interface ApplicationResponse
 */
export interface ApplicationResponse {
    /**
     * 
     * @type {Application}
     * @memberof ApplicationResponse
     */
    'application'?: Application;
    /**
     * Round at which the results were computed.
     * @type {number}
     * @memberof ApplicationResponse
     */
    'current-round': number;
}
/**
 * Specifies maximums on the number of each type that may be stored.
 * @export
 * @interface ApplicationStateSchema
 */
export interface ApplicationStateSchema {
    /**
     * \\[nui\\] num of uints.
     * @type {number}
     * @memberof ApplicationStateSchema
     */
    'num-uint': number;
    /**
     * \\[nbs\\] num of byte slices.
     * @type {number}
     * @memberof ApplicationStateSchema
     */
    'num-byte-slice': number;
}
/**
 * (empty)
 * @export
 * @interface ApplicationsResponse
 */
export interface ApplicationsResponse {
    /**
     * Used for pagination, when making another request provide this token with the next parameter.
     * @type {string}
     * @memberof ApplicationsResponse
     */
    'next-token'?: string;
    /**
     * Round at which the results were computed.
     * @type {number}
     * @memberof ApplicationsResponse
     */
    'current-round': number;
    /**
     * 
     * @type {Array<Application>}
     * @memberof ApplicationsResponse
     */
    'applications': Array<Application>;
}
/**
 * Specifies both the unique identifier and the parameters for an asset
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * Round during which this asset was destroyed.
     * @type {number}
     * @memberof Asset
     */
    'destroyed-at-round'?: number;
    /**
     * Whether or not this asset is currently deleted.
     * @type {boolean}
     * @memberof Asset
     */
    'deleted'?: boolean;
    /**
     * Round during which this asset was created.
     * @type {number}
     * @memberof Asset
     */
    'created-at-round'?: number;
    /**
     * unique asset identifier
     * @type {number}
     * @memberof Asset
     */
    'index': number;
    /**
     * 
     * @type {AssetParams}
     * @memberof Asset
     */
    'params': AssetParams;
}
/**
 * 
 * @export
 * @interface AssetBalanceResponse
 */
export interface AssetBalanceResponse {
    /**
     * Used for pagination, when making another request provide this token with the next parameter.
     * @type {string}
     * @memberof AssetBalanceResponse
     */
    'next-token'?: string;
    /**
     * 
     * @type {Array<MiniAssetHolding>}
     * @memberof AssetBalanceResponse
     */
    'balances': Array<MiniAssetHolding>;
    /**
     * Round at which the results were computed.
     * @type {number}
     * @memberof AssetBalanceResponse
     */
    'current-round': number;
}
/**
 * Describes an asset held by an account.  Definition: data/basics/userBalance.go : AssetHolding
 * @export
 * @interface AssetHolding
 */
export interface AssetHolding {
    /**
     * \\[a\\] number of units held.
     * @type {number}
     * @memberof AssetHolding
     */
    'amount': number;
    /**
     * Whether or not the asset holding is currently deleted from its account.
     * @type {boolean}
     * @memberof AssetHolding
     */
    'deleted'?: boolean;
    /**
     * Round during which the account opted out of this asset holding.
     * @type {number}
     * @memberof AssetHolding
     */
    'opted-out-at-round'?: number;
    /**
     * Asset ID of the holding.
     * @type {number}
     * @memberof AssetHolding
     */
    'asset-id': number;
    /**
     * \\[f\\] whether or not the holding is frozen.
     * @type {boolean}
     * @memberof AssetHolding
     */
    'is-frozen': boolean;
    /**
     * Round during which the account opted into this asset holding.
     * @type {number}
     * @memberof AssetHolding
     */
    'opted-in-at-round'?: number;
}
/**
 * AssetParams specifies the parameters for an asset.  \\[apar\\] when part of an AssetConfig transaction.  Definition: data/transactions/asset.go : AssetParams
 * @export
 * @interface AssetParams
 */
export interface AssetParams {
    /**
     * The address that created this asset. This is the address where the parameters for this asset can be found, and also the address where unwanted asset units can be sent in the worst case.
     * @type {string}
     * @memberof AssetParams
     */
    'creator': string;
    /**
     * \\[un\\] Name of a unit of this asset, as supplied by the creator. Included only when the name of a unit of this asset is composed of printable utf-8 characters.
     * @type {string}
     * @memberof AssetParams
     */
    'unit-name'?: string;
    /**
     * \\[m\\] Address of account used to manage the keys of this asset and to destroy it.
     * @type {string}
     * @memberof AssetParams
     */
    'manager'?: string;
    /**
     * \\[am\\] A commitment to some unspecified asset metadata. The format of this metadata is up to the application.
     * @type {string}
     * @memberof AssetParams
     */
    'metadata-hash'?: string;
    /**
     * Base64 encoded URL where more information about the asset can be retrieved.
     * @type {string}
     * @memberof AssetParams
     */
    'url-b64'?: string;
    /**
     * \\[au\\] URL where more information about the asset can be retrieved. Included only when the URL is composed of printable utf-8 characters.
     * @type {string}
     * @memberof AssetParams
     */
    'url'?: string;
    /**
     * \\[c\\] Address of account used to clawback holdings of this asset.  If empty, clawback is not permitted.
     * @type {string}
     * @memberof AssetParams
     */
    'clawback'?: string;
    /**
     * \\[df\\] Whether holdings of this asset are frozen by default.
     * @type {boolean}
     * @memberof AssetParams
     */
    'default-frozen'?: boolean;
    /**
     * Base64 encoded name of a unit of this asset, as supplied by the creator.
     * @type {string}
     * @memberof AssetParams
     */
    'unit-name-b64'?: string;
    /**
     * \\[t\\] The total number of units of this asset.
     * @type {number}
     * @memberof AssetParams
     */
    'total': number;
    /**
     * \\[f\\] Address of account used to freeze holdings of this asset.  If empty, freezing is not permitted.
     * @type {string}
     * @memberof AssetParams
     */
    'freeze'?: string;
    /**
     * \\[dc\\] The number of digits to use after the decimal point when displaying this asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in tenths. If 2, the base unit of the asset is in hundredths, and so on. This value must be between 0 and 19 (inclusive).
     * @type {number}
     * @memberof AssetParams
     */
    'decimals': number;
    /**
     * \\[an\\] Name of this asset, as supplied by the creator. Included only when the asset name is composed of printable utf-8 characters.
     * @type {string}
     * @memberof AssetParams
     */
    'name'?: string;
    /**
     * \\[r\\] Address of account holding reserve (non-minted) units of this asset.
     * @type {string}
     * @memberof AssetParams
     */
    'reserve'?: string;
    /**
     * Base64 encoded name of this asset, as supplied by the creator.
     * @type {string}
     * @memberof AssetParams
     */
    'name-b64'?: string;
}
/**
 * 
 * @export
 * @interface AssetResponse
 */
export interface AssetResponse {
    /**
     * Round at which the results were computed.
     * @type {number}
     * @memberof AssetResponse
     */
    'current-round': number;
    /**
     * 
     * @type {Asset}
     * @memberof AssetResponse
     */
    'asset': Asset;
}
/**
 * 
 * @export
 * @interface AssetsResponse
 */
export interface AssetsResponse {
    /**
     * Used for pagination, when making another request provide this token with the next parameter.
     * @type {string}
     * @memberof AssetsResponse
     */
    'next-token'?: string;
    /**
     * 
     * @type {Array<Asset>}
     * @memberof AssetsResponse
     */
    'assets': Array<Asset>;
    /**
     * Round at which the results were computed.
     * @type {number}
     * @memberof AssetsResponse
     */
    'current-round': number;
}
/**
 * Block information.  Definition: data/bookkeeping/block.go : Block
 * @export
 * @interface Block
 */
export interface Block {
    /**
     * 
     * @type {BlockUpgradeState}
     * @memberof Block
     */
    'upgrade-state'?: BlockUpgradeState;
    /**
     * \\[seed\\] Sortition seed.
     * @type {string}
     * @memberof Block
     */
    'seed': string;
    /**
     * Tracks the status of state proofs.
     * @type {Array<StateProofTracking>}
     * @memberof Block
     */
    'state-proof-tracking'?: Array<StateProofTracking>;
    /**
     * 
     * @type {BlockUpgradeVote}
     * @memberof Block
     */
    'upgrade-vote'?: BlockUpgradeVote;
    /**
     * \\[txns\\] list of transactions corresponding to a given round.
     * @type {Array<Transaction>}
     * @memberof Block
     */
    'transactions'?: Array<Transaction>;
    /**
     * \\[prev\\] Previous block hash.
     * @type {string}
     * @memberof Block
     */
    'previous-block-hash': string;
    /**
     * \\[gh\\] hash to which this block belongs.
     * @type {string}
     * @memberof Block
     */
    'genesis-hash': string;
    /**
     * \\[rnd\\] Current round on which this block was appended to the chain.
     * @type {number}
     * @memberof Block
     */
    'round': number;
    /**
     * \\[txn256\\] TransactionsRootSHA256 is an auxiliary TransactionRoot, built using a vector commitment instead of a merkle tree, and SHA256 hash function instead of the default SHA512_256. This commitment can be used on environments where only the SHA256 function exists.
     * @type {string}
     * @memberof Block
     */
    'transactions-root-sha256': string;
    /**
     * \\[txn\\] TransactionsRoot authenticates the set of transactions appearing in the block. More specifically, it\'s the root of a merkle tree whose leaves are the block\'s Txids, in lexicographic order. For the empty block, it\'s 0. Note that the TxnRoot does not authenticate the signatures on the transactions, only the transactions themselves. Two blocks with the same transactions but in a different order and with different signatures will have the same TxnRoot.
     * @type {string}
     * @memberof Block
     */
    'transactions-root': string;
    /**
     * \\[tc\\] TxnCounter counts the number of transactions committed in the ledger, from the time at which support for this feature was introduced.  Specifically, TxnCounter is the number of the next transaction that will be committed after this block.  It is 0 when no transactions have ever been committed (since TxnCounter started being supported).
     * @type {number}
     * @memberof Block
     */
    'txn-counter'?: number;
    /**
     * \\[gen\\] ID to which this block belongs.
     * @type {string}
     * @memberof Block
     */
    'genesis-id': string;
    /**
     * 
     * @type {BlockRewards}
     * @memberof Block
     */
    'rewards'?: BlockRewards;
    /**
     * 
     * @type {ParticipationUpdates}
     * @memberof Block
     */
    'participation-updates'?: ParticipationUpdates;
    /**
     * \\[ts\\] Block creation timestamp in seconds since eposh
     * @type {number}
     * @memberof Block
     */
    'timestamp': number;
}
/**
 * Fields relating to rewards,
 * @export
 * @interface BlockRewards
 */
export interface BlockRewards {
    /**
     * \\[rwcalr\\] number of leftover MicroAlgos after the distribution of rewards-rate MicroAlgos for every reward unit in the next round.
     * @type {number}
     * @memberof BlockRewards
     */
    'rewards-calculation-round': number;
    /**
     * \\[rate\\] Number of new MicroAlgos added to the participation stake from rewards at the next round.
     * @type {number}
     * @memberof BlockRewards
     */
    'rewards-rate': number;
    /**
     * \\[earn\\] How many rewards, in MicroAlgos, have been distributed to each RewardUnit of MicroAlgos since genesis.
     * @type {number}
     * @memberof BlockRewards
     */
    'rewards-level': number;
    /**
     * \\[fees\\] accepts transaction fees, it can only spend to the incentive pool.
     * @type {string}
     * @memberof BlockRewards
     */
    'fee-sink': string;
    /**
     * \\[rwd\\] accepts periodic injections from the fee-sink and continually redistributes them as rewards.
     * @type {string}
     * @memberof BlockRewards
     */
    'rewards-pool': string;
    /**
     * \\[frac\\] Number of leftover MicroAlgos after the distribution of RewardsRate/rewardUnits MicroAlgos for every reward unit in the next round.
     * @type {number}
     * @memberof BlockRewards
     */
    'rewards-residue': number;
}
/**
 * Fields relating to a protocol upgrade.
 * @export
 * @interface BlockUpgradeState
 */
export interface BlockUpgradeState {
    /**
     * \\[nextswitch\\] Round on which the protocol upgrade will take effect.
     * @type {number}
     * @memberof BlockUpgradeState
     */
    'next-protocol-switch-on'?: number;
    /**
     * \\[nextproto\\] The next proposed protocol version.
     * @type {string}
     * @memberof BlockUpgradeState
     */
    'next-protocol'?: string;
    /**
     * \\[nextbefore\\] Deadline round for this protocol upgrade (No votes will be consider after this round).
     * @type {number}
     * @memberof BlockUpgradeState
     */
    'next-protocol-vote-before'?: number;
    /**
     * \\[nextyes\\] Number of blocks which approved the protocol upgrade.
     * @type {number}
     * @memberof BlockUpgradeState
     */
    'next-protocol-approvals'?: number;
    /**
     * \\[proto\\] The current protocol version.
     * @type {string}
     * @memberof BlockUpgradeState
     */
    'current-protocol': string;
}
/**
 * Fields relating to voting for a protocol upgrade.
 * @export
 * @interface BlockUpgradeVote
 */
export interface BlockUpgradeVote {
    /**
     * \\[upgradedelay\\] Indicates the time between acceptance and execution.
     * @type {number}
     * @memberof BlockUpgradeVote
     */
    'upgrade-delay'?: number;
    /**
     * \\[upgradeyes\\] Indicates a yes vote for the current proposal.
     * @type {boolean}
     * @memberof BlockUpgradeVote
     */
    'upgrade-approve'?: boolean;
    /**
     * \\[upgradeprop\\] Indicates a proposed upgrade.
     * @type {string}
     * @memberof BlockUpgradeVote
     */
    'upgrade-propose'?: string;
}
/**
 * An error response with optional data field.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {object}
     * @memberof ErrorResponse
     */
    'data'?: object;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
}
/**
 * Represents a TEAL value delta.
 * @export
 * @interface EvalDelta
 */
export interface EvalDelta {
    /**
     * \\[bs\\] bytes value.
     * @type {string}
     * @memberof EvalDelta
     */
    'bytes'?: string;
    /**
     * \\[at\\] delta action.
     * @type {number}
     * @memberof EvalDelta
     */
    'action': number;
    /**
     * \\[ui\\] uint value.
     * @type {number}
     * @memberof EvalDelta
     */
    'uint'?: number;
}
/**
 * Key-value pairs for StateDelta.
 * @export
 * @interface EvalDeltaKeyValue
 */
export interface EvalDeltaKeyValue {
    /**
     * 
     * @type {EvalDelta}
     * @memberof EvalDeltaKeyValue
     */
    'value': EvalDelta;
    /**
     * 
     * @type {string}
     * @memberof EvalDeltaKeyValue
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface HashFactory
 */
export interface HashFactory {
    /**
     * \\[t\\]
     * @type {number}
     * @memberof HashFactory
     */
    'hash-type'?: number;
}
/**
 * A health check response.
 * @export
 * @interface HealthCheckResponse
 */
export interface HealthCheckResponse {
    /**
     * 
     * @type {boolean}
     * @memberof HealthCheckResponse
     */
    'db-available': boolean;
    /**
     * 
     * @type {object}
     * @memberof HealthCheckResponse
     */
    'data'?: object;
    /**
     * 
     * @type {number}
     * @memberof HealthCheckResponse
     */
    'round': number;
    /**
     * 
     * @type {string}
     * @memberof HealthCheckResponse
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof HealthCheckResponse
     */
    'is-migrating': boolean;
    /**
     * Current version
     * @type {string}
     * @memberof HealthCheckResponse
     */
    'version': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof HealthCheckResponse
     */
    'errors'?: Array<string>;
}
/**
 * 
 * @export
 * @interface IndexerStateProofMessage
 */
export interface IndexerStateProofMessage {
    /**
     * \\[P\\]
     * @type {number}
     * @memberof IndexerStateProofMessage
     */
    'ln-proven-weight'?: number;
    /**
     * \\[b\\]
     * @type {string}
     * @memberof IndexerStateProofMessage
     */
    'block-headers-commitment'?: string;
    /**
     * \\[v\\]
     * @type {string}
     * @memberof IndexerStateProofMessage
     */
    'voters-commitment'?: string;
    /**
     * \\[l\\]
     * @type {number}
     * @memberof IndexerStateProofMessage
     */
    'latest-attested-round'?: number;
    /**
     * \\[f\\]
     * @type {number}
     * @memberof IndexerStateProofMessage
     */
    'first-attested-round'?: number;
}
/**
 * 
 * @export
 * @interface MerkleArrayProof
 */
export interface MerkleArrayProof {
    /**
     * \\[pth\\]
     * @type {Array<string>}
     * @memberof MerkleArrayProof
     */
    'path'?: Array<string>;
    /**
     * \\[td\\]
     * @type {number}
     * @memberof MerkleArrayProof
     */
    'tree-depth'?: number;
    /**
     * 
     * @type {HashFactory}
     * @memberof MerkleArrayProof
     */
    'hash-factory'?: HashFactory;
}
/**
 * A simplified version of AssetHolding 
 * @export
 * @interface MiniAssetHolding
 */
export interface MiniAssetHolding {
    /**
     * 
     * @type {number}
     * @memberof MiniAssetHolding
     */
    'amount': number;
    /**
     * Whether or not this asset holding is currently deleted from its account.
     * @type {boolean}
     * @memberof MiniAssetHolding
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MiniAssetHolding
     */
    'address': string;
    /**
     * Round during which the account opted out of the asset.
     * @type {number}
     * @memberof MiniAssetHolding
     */
    'opted-out-at-round'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MiniAssetHolding
     */
    'is-frozen': boolean;
    /**
     * Round during which the account opted into the asset.
     * @type {number}
     * @memberof MiniAssetHolding
     */
    'opted-in-at-round'?: number;
}
/**
 * \\[apan\\] defines the what additional actions occur with the transaction.  Valid types: * noop * optin * closeout * clear * update * update * delete
 * @export
 * @enum {string}
 */

export const OnCompletion = {
    Noop: 'noop',
    Optin: 'optin',
    Closeout: 'closeout',
    Clear: 'clear',
    Update: 'update',
    Delete: 'delete'
} as const;

export type OnCompletion = typeof OnCompletion[keyof typeof OnCompletion];


/**
 * Participation account data that needs to be checked/acted on by the network.
 * @export
 * @interface ParticipationUpdates
 */
export interface ParticipationUpdates {
    /**
     * \\[partupdrmv\\] a list of online accounts that needs to be converted to offline since their participation key expired.
     * @type {Array<string>}
     * @memberof ParticipationUpdates
     */
    'expired-participation-accounts'?: Array<string>;
}
/**
 * \\[sp\\] represents a state proof.
 * @export
 * @interface StateProofFields
 */
export interface StateProofFields {
    /**
     * 
     * @type {MerkleArrayProof}
     * @memberof StateProofFields
     */
    'sig-proofs'?: MerkleArrayProof;
    /**
     * \\[w\\]
     * @type {number}
     * @memberof StateProofFields
     */
    'signed-weight'?: number;
    /**
     * \\[pr\\] Sequence of reveal positions.
     * @type {Array<number>}
     * @memberof StateProofFields
     */
    'positions-to-reveal'?: Array<number>;
    /**
     * \\[r\\] Note that this is actually stored as a map[uint64] - Reveal in the actual msgp
     * @type {Array<StateProofReveal>}
     * @memberof StateProofFields
     */
    'reveals'?: Array<StateProofReveal>;
    /**
     * \\[c\\]
     * @type {string}
     * @memberof StateProofFields
     */
    'sig-commit'?: string;
    /**
     * 
     * @type {MerkleArrayProof}
     * @memberof StateProofFields
     */
    'part-proofs'?: MerkleArrayProof;
    /**
     * \\[v\\] Salt version of the merkle signature.
     * @type {number}
     * @memberof StateProofFields
     */
    'salt-version'?: number;
}
/**
 * 
 * @export
 * @interface StateProofParticipant
 */
export interface StateProofParticipant {
    /**
     * 
     * @type {StateProofVerifier}
     * @memberof StateProofParticipant
     */
    'verifier'?: StateProofVerifier;
    /**
     * \\[w\\]
     * @type {number}
     * @memberof StateProofParticipant
     */
    'weight'?: number;
}
/**
 * 
 * @export
 * @interface StateProofReveal
 */
export interface StateProofReveal {
    /**
     * 
     * @type {StateProofSigSlot}
     * @memberof StateProofReveal
     */
    'sig-slot'?: StateProofSigSlot;
    /**
     * The position in the signature and participants arrays corresponding to this entry.
     * @type {number}
     * @memberof StateProofReveal
     */
    'position'?: number;
    /**
     * 
     * @type {StateProofParticipant}
     * @memberof StateProofReveal
     */
    'participant'?: StateProofParticipant;
}
/**
 * 
 * @export
 * @interface StateProofSigSlot
 */
export interface StateProofSigSlot {
    /**
     * 
     * @type {StateProofSignature}
     * @memberof StateProofSigSlot
     */
    'signature'?: StateProofSignature;
    /**
     * \\[l\\] The total weight of signatures in the lower-numbered slots.
     * @type {number}
     * @memberof StateProofSigSlot
     */
    'lower-sig-weight'?: number;
}
/**
 * 
 * @export
 * @interface StateProofSignature
 */
export interface StateProofSignature {
    /**
     * \\[vkey\\]
     * @type {string}
     * @memberof StateProofSignature
     */
    'verifying-key'?: string;
    /**
     * 
     * @type {MerkleArrayProof}
     * @memberof StateProofSignature
     */
    'proof'?: MerkleArrayProof;
    /**
     * 
     * @type {number}
     * @memberof StateProofSignature
     */
    'merkle-array-index'?: number;
    /**
     * 
     * @type {string}
     * @memberof StateProofSignature
     */
    'falcon-signature'?: string;
}
/**
 * 
 * @export
 * @interface StateProofTracking
 */
export interface StateProofTracking {
    /**
     * \\[n\\] Next round for which we will accept a state proof transaction.
     * @type {number}
     * @memberof StateProofTracking
     */
    'next-round'?: number;
    /**
     * \\[t\\] The total number of microalgos held by the online accounts during the StateProof round.
     * @type {number}
     * @memberof StateProofTracking
     */
    'online-total-weight'?: number;
    /**
     * \\[v\\] Root of a vector commitment containing online accounts that will help sign the proof.
     * @type {string}
     * @memberof StateProofTracking
     */
    'voters-commitment'?: string;
    /**
     * State Proof Type. Note the raw object uses map with this as key.
     * @type {number}
     * @memberof StateProofTracking
     */
    'type'?: number;
}
/**
 * 
 * @export
 * @interface StateProofVerifier
 */
export interface StateProofVerifier {
    /**
     * \\[cmt\\] Represents the root of the vector commitment tree.
     * @type {string}
     * @memberof StateProofVerifier
     */
    'commitment'?: string;
    /**
     * \\[lf\\] Key lifetime.
     * @type {number}
     * @memberof StateProofVerifier
     */
    'key-lifetime'?: number;
}
/**
 * Represents a \\[apls\\] local-state or \\[apgs\\] global-state schema. These schemas determine how much storage may be used in a local-state or global-state for an application. The more space used, the larger minimum balance must be maintained in the account holding the data.
 * @export
 * @interface StateSchema
 */
export interface StateSchema {
    /**
     * Maximum number of TEAL uints that may be stored in the key/value store.
     * @type {number}
     * @memberof StateSchema
     */
    'num-uint': number;
    /**
     * Maximum number of TEAL byte slices that may be stored in the key/value store.
     * @type {number}
     * @memberof StateSchema
     */
    'num-byte-slice': number;
}
/**
 * Represents a key-value pair in an application store.
 * @export
 * @interface TealKeyValue
 */
export interface TealKeyValue {
    /**
     * 
     * @type {TealValue}
     * @memberof TealKeyValue
     */
    'value': TealValue;
    /**
     * 
     * @type {string}
     * @memberof TealKeyValue
     */
    'key': string;
}
/**
 * Represents a TEAL value.
 * @export
 * @interface TealValue
 */
export interface TealValue {
    /**
     * \\[tb\\] bytes value.
     * @type {string}
     * @memberof TealValue
     */
    'bytes': string;
    /**
     * \\[tt\\] value type. Value `1` refers to **bytes**, value `2` refers to **uint**
     * @type {number}
     * @memberof TealValue
     */
    'type': number;
    /**
     * \\[ui\\] uint value.
     * @type {number}
     * @memberof TealValue
     */
    'uint': number;
}
/**
 * Contains all fields common to all transactions and serves as an envelope to all transactions type. Represents both regular and inner transactions.  Definition: data/transactions/signedtxn.go : SignedTxn data/transactions/transaction.go : Transaction 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * \\[note\\] Free form data.
     * @type {string}
     * @memberof Transaction
     */
    'note'?: string;
    /**
     * 
     * @type {TransactionSignature}
     * @memberof Transaction
     */
    'signature'?: TransactionSignature;
    /**
     * \\[fee\\] Transaction fee.
     * @type {number}
     * @memberof Transaction
     */
    'fee': number;
    /**
     * Specifies an application index (ID) if an application was created with this transaction.
     * @type {number}
     * @memberof Transaction
     */
    'created-application-index'?: number;
    /**
     * \\[ld\\] Local state key/value changes for the application being executed by this transaction.
     * @type {Array<AccountStateDelta>}
     * @memberof Transaction
     */
    'local-state-delta'?: Array<AccountStateDelta>;
    /**
     * \\[ca\\] closing amount for transaction.
     * @type {number}
     * @memberof Transaction
     */
    'closing-amount'?: number;
    /**
     * 
     * @type {TransactionAssetTransfer}
     * @memberof Transaction
     */
    'asset-transfer-transaction'?: TransactionAssetTransfer;
    /**
     * \\[gh\\] Hash of genesis block.
     * @type {string}
     * @memberof Transaction
     */
    'genesis-hash'?: string;
    /**
     * Offset into the round where this transaction was confirmed.
     * @type {number}
     * @memberof Transaction
     */
    'intra-round-offset'?: number;
    /**
     * 
     * @type {TransactionAssetFreeze}
     * @memberof Transaction
     */
    'asset-freeze-transaction'?: TransactionAssetFreeze;
    /**
     * 
     * @type {TransactionAssetConfig}
     * @memberof Transaction
     */
    'asset-config-transaction'?: TransactionAssetConfig;
    /**
     * 
     * @type {TransactionPayment}
     * @memberof Transaction
     */
    'payment-transaction'?: TransactionPayment;
    /**
     * Transaction ID
     * @type {string}
     * @memberof Transaction
     */
    'id'?: string;
    /**
     * Specifies an asset index (ID) if an asset was created with this transaction.
     * @type {number}
     * @memberof Transaction
     */
    'created-asset-index'?: number;
    /**
     * \\[lg\\] Logs for the application being executed by this transaction.
     * @type {Array<string>}
     * @memberof Transaction
     */
    'logs'?: Array<string>;
    /**
     * 
     * @type {TransactionKeyreg}
     * @memberof Transaction
     */
    'keyreg-transaction'?: TransactionKeyreg;
    /**
     * \\[lv\\] Last valid round for this transaction.
     * @type {number}
     * @memberof Transaction
     */
    'last-valid': number;
    /**
     * \\[grp\\] Base64 encoded byte array of a sha512/256 digest. When present indicates that this transaction is part of a transaction group and the value is the sha512/256 hash of the transactions in that group.
     * @type {string}
     * @memberof Transaction
     */
    'group'?: string;
    /**
     * Time when the block this transaction is in was confirmed.
     * @type {number}
     * @memberof Transaction
     */
    'round-time'?: number;
    /**
     * \\[rr\\] rewards applied to receiver account.
     * @type {number}
     * @memberof Transaction
     */
    'receiver-rewards'?: number;
    /**
     * \\[rekey\\] when included in a valid transaction, the accounts auth addr will be updated with this value and future signatures must be signed with the key represented by this address.
     * @type {string}
     * @memberof Transaction
     */
    'rekey-to'?: string;
    /**
     * Round when the transaction was confirmed.
     * @type {number}
     * @memberof Transaction
     */
    'confirmed-round'?: number;
    /**
     * \\[type\\] Indicates what type of transaction this is. Different types have different fields.  Valid types, and where their fields are stored: * \\[pay\\] payment-transaction * \\[keyreg\\] keyreg-transaction * \\[acfg\\] asset-config-transaction * \\[axfer\\] asset-transfer-transaction * \\[afrz\\] asset-freeze-transaction * \\[appl\\] application-transaction * \\[stpf\\] state-proof-transaction
     * @type {string}
     * @memberof Transaction
     */
    'tx-type': TransactionTxTypeEnum;
    /**
     * \\[rs\\] rewards applied to sender account.
     * @type {number}
     * @memberof Transaction
     */
    'sender-rewards'?: number;
    /**
     * 
     * @type {TransactionApplication}
     * @memberof Transaction
     */
    'application-transaction'?: TransactionApplication;
    /**
     * 
     * @type {TransactionStateProof}
     * @memberof Transaction
     */
    'state-proof-transaction'?: TransactionStateProof;
    /**
     * \\[snd\\] Sender\'s address.
     * @type {string}
     * @memberof Transaction
     */
    'sender': string;
    /**
     * Inner transactions produced by application execution.
     * @type {Array<Transaction>}
     * @memberof Transaction
     */
    'inner-txns'?: Array<Transaction>;
    /**
     * \\[fv\\] First valid round for this transaction.
     * @type {number}
     * @memberof Transaction
     */
    'first-valid': number;
    /**
     * \\[lx\\] Base64 encoded 32-byte array. Lease enforces mutual exclusion of transactions.  If this field is nonzero, then once the transaction is confirmed, it acquires the lease identified by the (Sender, Lease) pair of the transaction until the LastValid round passes.  While this transaction possesses the lease, no other transaction specifying this lease can be confirmed.
     * @type {string}
     * @memberof Transaction
     */
    'lease'?: string;
    /**
     * \\[gen\\] genesis block ID.
     * @type {string}
     * @memberof Transaction
     */
    'genesis-id'?: string;
    /**
     * \\[rc\\] rewards applied to close-remainder-to account.
     * @type {number}
     * @memberof Transaction
     */
    'close-rewards'?: number;
    /**
     * \\[sgnr\\] The address used to sign the transaction. This is used for rekeyed accounts to indicate that the sender address did not sign the transaction.
     * @type {string}
     * @memberof Transaction
     */
    'auth-addr'?: string;
    /**
     * Application state delta.
     * @type {Array<EvalDeltaKeyValue>}
     * @memberof Transaction
     */
    'global-state-delta'?: Array<EvalDeltaKeyValue>;
}

export const TransactionTxTypeEnum = {
    Pay: 'pay',
    Keyreg: 'keyreg',
    Acfg: 'acfg',
    Axfer: 'axfer',
    Afrz: 'afrz',
    Appl: 'appl',
    Stpf: 'stpf'
} as const;

export type TransactionTxTypeEnum = typeof TransactionTxTypeEnum[keyof typeof TransactionTxTypeEnum];

/**
 * Fields for application transactions.  Definition: data/transactions/application.go : ApplicationCallTxnFields
 * @export
 * @interface TransactionApplication
 */
export interface TransactionApplication {
    /**
     * \\[apsu\\] Logic executed for application transactions with on-completion set to \"clear\". It can read and write global state for the application, as well as account-specific local state. Clear state programs cannot reject the transaction.
     * @type {string}
     * @memberof TransactionApplication
     */
    'clear-state-program'?: string;
    /**
     * 
     * @type {StateSchema}
     * @memberof TransactionApplication
     */
    'local-state-schema'?: StateSchema;
    /**
     * \\[apfa\\] Lists the applications in addition to the application-id whose global states may be accessed by this application\'s approval-program and clear-state-program. The access is read-only.
     * @type {Array<number>}
     * @memberof TransactionApplication
     */
    'foreign-apps'?: Array<number>;
    /**
     * \\[apap\\] Logic executed for every application transaction, except when on-completion is set to \"clear\". It can read and write global state for the application, as well as account-specific local state. Approval programs may reject the transaction.
     * @type {string}
     * @memberof TransactionApplication
     */
    'approval-program'?: string;
    /**
     * \\[apaa\\] transaction specific arguments accessed from the application\'s approval-program and clear-state-program.
     * @type {Array<string>}
     * @memberof TransactionApplication
     */
    'application-args'?: Array<string>;
    /**
     * \\[apas\\] lists the assets whose parameters may be accessed by this application\'s ApprovalProgram and ClearStateProgram. The access is read-only.
     * @type {Array<number>}
     * @memberof TransactionApplication
     */
    'foreign-assets'?: Array<number>;
    /**
     * \\[apat\\] List of accounts in addition to the sender that may be accessed from the application\'s approval-program and clear-state-program.
     * @type {Array<string>}
     * @memberof TransactionApplication
     */
    'accounts'?: Array<string>;
    /**
     * 
     * @type {OnCompletion}
     * @memberof TransactionApplication
     */
    'on-completion': OnCompletion;
    /**
     * \\[apid\\] ID of the application being configured or empty if creating.
     * @type {number}
     * @memberof TransactionApplication
     */
    'application-id': number;
    /**
     * 
     * @type {StateSchema}
     * @memberof TransactionApplication
     */
    'global-state-schema'?: StateSchema;
}


/**
 * Fields for asset allocation, re-configuration, and destruction.   A zero value for asset-id indicates asset creation. A zero value for the params indicates asset destruction.  Definition: data/transactions/asset.go : AssetConfigTxnFields
 * @export
 * @interface TransactionAssetConfig
 */
export interface TransactionAssetConfig {
    /**
     * \\[xaid\\] ID of the asset being configured or empty if creating.
     * @type {number}
     * @memberof TransactionAssetConfig
     */
    'asset-id'?: number;
    /**
     * 
     * @type {AssetParams}
     * @memberof TransactionAssetConfig
     */
    'params'?: AssetParams;
}
/**
 * Fields for an asset freeze transaction.  Definition: data/transactions/asset.go : AssetFreezeTxnFields
 * @export
 * @interface TransactionAssetFreeze
 */
export interface TransactionAssetFreeze {
    /**
     * \\[fadd\\] Address of the account whose asset is being frozen or thawed.
     * @type {string}
     * @memberof TransactionAssetFreeze
     */
    'address': string;
    /**
     * \\[faid\\] ID of the asset being frozen or thawed.
     * @type {number}
     * @memberof TransactionAssetFreeze
     */
    'asset-id': number;
    /**
     * \\[afrz\\] The new freeze status.
     * @type {boolean}
     * @memberof TransactionAssetFreeze
     */
    'new-freeze-status': boolean;
}
/**
 * Fields for an asset transfer transaction.  Definition: data/transactions/asset.go : AssetTransferTxnFields
 * @export
 * @interface TransactionAssetTransfer
 */
export interface TransactionAssetTransfer {
    /**
     * Number of assets transfered to the close-to account as part of the transaction.
     * @type {number}
     * @memberof TransactionAssetTransfer
     */
    'close-amount'?: number;
    /**
     * \\[aamt\\] Amount of asset to transfer. A zero amount transferred to self allocates that asset in the account\'s Assets map.
     * @type {number}
     * @memberof TransactionAssetTransfer
     */
    'amount': number;
    /**
     * \\[aclose\\] Indicates that the asset should be removed from the account\'s Assets map, and specifies where the remaining asset holdings should be transferred.  It\'s always valid to transfer remaining asset holdings to the creator account.
     * @type {string}
     * @memberof TransactionAssetTransfer
     */
    'close-to'?: string;
    /**
     * \\[arcv\\] Recipient address of the transfer.
     * @type {string}
     * @memberof TransactionAssetTransfer
     */
    'receiver': string;
    /**
     * \\[asnd\\] The effective sender during a clawback transactions. If this is not a zero value, the real transaction sender must be the Clawback address from the AssetParams.
     * @type {string}
     * @memberof TransactionAssetTransfer
     */
    'sender'?: string;
    /**
     * \\[xaid\\] ID of the asset being transferred.
     * @type {number}
     * @memberof TransactionAssetTransfer
     */
    'asset-id': number;
}
/**
 * Fields for a keyreg transaction.  Definition: data/transactions/keyreg.go : KeyregTxnFields
 * @export
 * @interface TransactionKeyreg
 */
export interface TransactionKeyreg {
    /**
     * \\[nonpart\\] Mark the account as participating or non-participating.
     * @type {boolean}
     * @memberof TransactionKeyreg
     */
    'non-participation'?: boolean;
    /**
     * \\[sprfkey\\] State proof key used in key registration transactions.
     * @type {string}
     * @memberof TransactionKeyreg
     */
    'state-proof-key'?: string;
    /**
     * \\[votekey\\] Participation public key used in key registration transactions.
     * @type {string}
     * @memberof TransactionKeyreg
     */
    'vote-participation-key'?: string;
    /**
     * \\[votelst\\] Last round this participation key is valid.
     * @type {number}
     * @memberof TransactionKeyreg
     */
    'vote-last-valid'?: number;
    /**
     * \\[votekd\\] Number of subkeys in each batch of participation keys.
     * @type {number}
     * @memberof TransactionKeyreg
     */
    'vote-key-dilution'?: number;
    /**
     * \\[votefst\\] First round this participation key is valid.
     * @type {number}
     * @memberof TransactionKeyreg
     */
    'vote-first-valid'?: number;
    /**
     * \\[selkey\\] Public key used with the Verified Random Function (VRF) result during committee selection.
     * @type {string}
     * @memberof TransactionKeyreg
     */
    'selection-participation-key'?: string;
}
/**
 * Fields for a payment transaction.  Definition: data/transactions/payment.go : PaymentTxnFields
 * @export
 * @interface TransactionPayment
 */
export interface TransactionPayment {
    /**
     * Number of MicroAlgos that were sent to the close-remainder-to address when closing the sender account.
     * @type {number}
     * @memberof TransactionPayment
     */
    'close-amount'?: number;
    /**
     * \\[amt\\] number of MicroAlgos intended to be transferred.
     * @type {number}
     * @memberof TransactionPayment
     */
    'amount': number;
    /**
     * \\[rcv\\] receiver\'s address.
     * @type {string}
     * @memberof TransactionPayment
     */
    'receiver': string;
    /**
     * \\[close\\] when set, indicates that the sending account should be closed and all remaining funds be transferred to this address.
     * @type {string}
     * @memberof TransactionPayment
     */
    'close-remainder-to'?: string;
}
/**
 * 
 * @export
 * @interface TransactionResponse
 */
export interface TransactionResponse {
    /**
     * Round at which the results were computed.
     * @type {number}
     * @memberof TransactionResponse
     */
    'current-round': number;
    /**
     * 
     * @type {Transaction}
     * @memberof TransactionResponse
     */
    'transaction': Transaction;
}
/**
 * Validation signature associated with some data. Only one of the signatures should be provided.
 * @export
 * @interface TransactionSignature
 */
export interface TransactionSignature {
    /**
     * \\[sig\\] Standard ed25519 signature.
     * @type {string}
     * @memberof TransactionSignature
     */
    'sig'?: string;
    /**
     * 
     * @type {TransactionSignatureMultisig}
     * @memberof TransactionSignature
     */
    'multisig'?: TransactionSignatureMultisig;
    /**
     * 
     * @type {TransactionSignatureLogicsig}
     * @memberof TransactionSignature
     */
    'logicsig'?: TransactionSignatureLogicsig;
}
/**
 * \\[lsig\\] Programatic transaction signature.  Definition: data/transactions/logicsig.go
 * @export
 * @interface TransactionSignatureLogicsig
 */
export interface TransactionSignatureLogicsig {
    /**
     * \\[arg\\] Logic arguments, base64 encoded.
     * @type {Array<string>}
     * @memberof TransactionSignatureLogicsig
     */
    'args'?: Array<string>;
    /**
     * 
     * @type {TransactionSignatureMultisig}
     * @memberof TransactionSignatureLogicsig
     */
    'multisig-signature'?: TransactionSignatureMultisig;
    /**
     * \\[sig\\] ed25519 signature.
     * @type {string}
     * @memberof TransactionSignatureLogicsig
     */
    'signature'?: string;
    /**
     * \\[l\\] Program signed by a signature or multi signature, or hashed to be the address of ana ccount. Base64 encoded TEAL program.
     * @type {string}
     * @memberof TransactionSignatureLogicsig
     */
    'logic': string;
}
/**
 * \\[msig\\] structure holding multiple subsignatures.  Definition: crypto/multisig.go : MultisigSig
 * @export
 * @interface TransactionSignatureMultisig
 */
export interface TransactionSignatureMultisig {
    /**
     * \\[subsig\\] holds pairs of public key and signatures.
     * @type {Array<TransactionSignatureMultisigSubsignature>}
     * @memberof TransactionSignatureMultisig
     */
    'subsignature'?: Array<TransactionSignatureMultisigSubsignature>;
    /**
     * \\[thr\\]
     * @type {number}
     * @memberof TransactionSignatureMultisig
     */
    'threshold'?: number;
    /**
     * \\[v\\]
     * @type {number}
     * @memberof TransactionSignatureMultisig
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface TransactionSignatureMultisigSubsignature
 */
export interface TransactionSignatureMultisigSubsignature {
    /**
     * \\[s\\]
     * @type {string}
     * @memberof TransactionSignatureMultisigSubsignature
     */
    'signature'?: string;
    /**
     * \\[pk\\]
     * @type {string}
     * @memberof TransactionSignatureMultisigSubsignature
     */
    'public-key'?: string;
}
/**
 * Fields for a state proof transaction.
 * @export
 * @interface TransactionStateProof
 */
export interface TransactionStateProof {
    /**
     * 
     * @type {StateProofFields}
     * @memberof TransactionStateProof
     */
    'state-proof'?: StateProofFields;
    /**
     * \\[sptype\\] Type of the state proof. Integer representing an entry defined in protocol/stateproof.go
     * @type {number}
     * @memberof TransactionStateProof
     */
    'state-proof-type'?: number;
    /**
     * 
     * @type {IndexerStateProofMessage}
     * @memberof TransactionStateProof
     */
    'message'?: IndexerStateProofMessage;
}
/**
 * 
 * @export
 * @interface TransactionsResponse
 */
export interface TransactionsResponse {
    /**
     * Used for pagination, when making another request provide this token with the next parameter.
     * @type {string}
     * @memberof TransactionsResponse
     */
    'next-token'?: string;
    /**
     * Round at which the results were computed.
     * @type {number}
     * @memberof TransactionsResponse
     */
    'current-round': number;
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof TransactionsResponse
     */
    'transactions': Array<Transaction>;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} [limit] 
         * @param {string} [applicationId] 
         * @param {string} [includeAll] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAccountAppLocalStates: async (accountId: string, limit?: string, applicationId?: string, includeAll?: string, next?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('lookupAccountAppLocalStates', 'accountId', accountId)
            const localVarPath = `/v2/accounts/{account-id}/apps-local-state`
                .replace(`{${"account-id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['application-id'] = applicationId;
            }

            if (includeAll !== undefined) {
                localVarQueryParameter['include-all'] = includeAll;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} [limit] 
         * @param {string} [includeAll] 
         * @param {string} [assetId] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAccountAssets: async (accountId: string, limit?: string, includeAll?: string, assetId?: string, next?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('lookupAccountAssets', 'accountId', accountId)
            const localVarPath = `/v2/accounts/{account-id}/assets`
                .replace(`{${"account-id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (includeAll !== undefined) {
                localVarQueryParameter['include-all'] = includeAll;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset-id'] = assetId;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} [round] 
         * @param {string} [includeAll] 
         * @param {string} [exclude] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAccountByID: async (accountId: string, round?: string, includeAll?: string, exclude?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('lookupAccountByID', 'accountId', accountId)
            const localVarPath = `/v2/accounts/{account-id}`
                .replace(`{${"account-id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (round !== undefined) {
                localVarQueryParameter['round'] = round;
            }

            if (includeAll !== undefined) {
                localVarQueryParameter['include-all'] = includeAll;
            }

            if (exclude !== undefined) {
                localVarQueryParameter['exclude'] = exclude;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} [limit] 
         * @param {string} [applicationId] 
         * @param {string} [includeAll] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAccountCreatedApplications: async (accountId: string, limit?: string, applicationId?: string, includeAll?: string, next?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('lookupAccountCreatedApplications', 'accountId', accountId)
            const localVarPath = `/v2/accounts/{account-id}/created-applications`
                .replace(`{${"account-id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['application-id'] = applicationId;
            }

            if (includeAll !== undefined) {
                localVarQueryParameter['include-all'] = includeAll;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} [limit] 
         * @param {string} [includeAll] 
         * @param {string} [assetId] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAccountCreatedAssets: async (accountId: string, limit?: string, includeAll?: string, assetId?: string, next?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('lookupAccountCreatedAssets', 'accountId', accountId)
            const localVarPath = `/v2/accounts/{account-id}/created-assets`
                .replace(`{${"account-id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (includeAll !== undefined) {
                localVarQueryParameter['include-all'] = includeAll;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset-id'] = assetId;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} [sigType] 
         * @param {string} [notePrefix] 
         * @param {string} [round] 
         * @param {string} [txid] 
         * @param {string} [txType] 
         * @param {string} [currencyGreaterThan] 
         * @param {string} [limit] 
         * @param {string} [minRound] 
         * @param {string} [assetId] 
         * @param {string} [maxRound] 
         * @param {string} [rekeyTo] 
         * @param {string} [beforeTime] 
         * @param {string} [currencyLessThan] 
         * @param {string} [afterTime] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAccountTransactions: async (accountId: string, sigType?: string, notePrefix?: string, round?: string, txid?: string, txType?: string, currencyGreaterThan?: string, limit?: string, minRound?: string, assetId?: string, maxRound?: string, rekeyTo?: string, beforeTime?: string, currencyLessThan?: string, afterTime?: string, next?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('lookupAccountTransactions', 'accountId', accountId)
            const localVarPath = `/v2/accounts/{account-id}/transactions`
                .replace(`{${"account-id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (sigType !== undefined) {
                localVarQueryParameter['sig-type'] = sigType;
            }

            if (notePrefix !== undefined) {
                localVarQueryParameter['note-prefix'] = notePrefix;
            }

            if (round !== undefined) {
                localVarQueryParameter['round'] = round;
            }

            if (txid !== undefined) {
                localVarQueryParameter['txid'] = txid;
            }

            if (txType !== undefined) {
                localVarQueryParameter['tx-type'] = txType;
            }

            if (currencyGreaterThan !== undefined) {
                localVarQueryParameter['currency-greater-than'] = currencyGreaterThan;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (minRound !== undefined) {
                localVarQueryParameter['min-round'] = minRound;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset-id'] = assetId;
            }

            if (maxRound !== undefined) {
                localVarQueryParameter['max-round'] = maxRound;
            }

            if (rekeyTo !== undefined) {
                localVarQueryParameter['rekey-to'] = rekeyTo;
            }

            if (beforeTime !== undefined) {
                localVarQueryParameter['before-time'] = beforeTime;
            }

            if (currencyLessThan !== undefined) {
                localVarQueryParameter['currency-less-than'] = currencyLessThan;
            }

            if (afterTime !== undefined) {
                localVarQueryParameter['after-time'] = afterTime;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupApplicationBoxByIDAndName: async (applicationId: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('lookupApplicationBoxByIDAndName', 'applicationId', applicationId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('lookupApplicationBoxByIDAndName', 'name', name)
            const localVarPath = `/v2/applications/{application-id}/box`
                .replace(`{${"application-id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [includeAll] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupApplicationByID: async (applicationId: string, includeAll?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('lookupApplicationByID', 'applicationId', applicationId)
            const localVarPath = `/v2/applications/{application-id}`
                .replace(`{${"application-id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (includeAll !== undefined) {
                localVarQueryParameter['include-all'] = includeAll;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [limit] 
         * @param {string} [minRound] 
         * @param {string} [senderAddress] 
         * @param {string} [maxRound] 
         * @param {string} [txid] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupApplicationLogsByID: async (applicationId: string, limit?: string, minRound?: string, senderAddress?: string, maxRound?: string, txid?: string, next?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('lookupApplicationLogsByID', 'applicationId', applicationId)
            const localVarPath = `/v2/applications/{application-id}/logs`
                .replace(`{${"application-id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (minRound !== undefined) {
                localVarQueryParameter['min-round'] = minRound;
            }

            if (senderAddress !== undefined) {
                localVarQueryParameter['sender-address'] = senderAddress;
            }

            if (maxRound !== undefined) {
                localVarQueryParameter['max-round'] = maxRound;
            }

            if (txid !== undefined) {
                localVarQueryParameter['txid'] = txid;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assetId 
         * @param {string} [currencyLessThan] 
         * @param {string} [limit] 
         * @param {string} [includeAll] 
         * @param {string} [next] 
         * @param {string} [currencyGreaterThan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAssetBalances: async (assetId: string, currencyLessThan?: string, limit?: string, includeAll?: string, next?: string, currencyGreaterThan?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('lookupAssetBalances', 'assetId', assetId)
            const localVarPath = `/v2/assets/{asset-id}/balances`
                .replace(`{${"asset-id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (currencyLessThan !== undefined) {
                localVarQueryParameter['currency-less-than'] = currencyLessThan;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (includeAll !== undefined) {
                localVarQueryParameter['include-all'] = includeAll;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (currencyGreaterThan !== undefined) {
                localVarQueryParameter['currency-greater-than'] = currencyGreaterThan;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assetId 
         * @param {string} [includeAll] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAssetByID: async (assetId: string, includeAll?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('lookupAssetByID', 'assetId', assetId)
            const localVarPath = `/v2/assets/{asset-id}`
                .replace(`{${"asset-id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (includeAll !== undefined) {
                localVarQueryParameter['include-all'] = includeAll;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assetId 
         * @param {string} [sigType] 
         * @param {string} [address] 
         * @param {string} [notePrefix] 
         * @param {string} [round] 
         * @param {string} [txid] 
         * @param {string} [txType] 
         * @param {string} [currencyGreaterThan] 
         * @param {string} [addressRole] 
         * @param {string} [limit] 
         * @param {string} [minRound] 
         * @param {string} [excludeCloseTo] 
         * @param {string} [maxRound] 
         * @param {string} [rekeyTo] 
         * @param {string} [beforeTime] 
         * @param {string} [currencyLessThan] 
         * @param {string} [afterTime] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAssetTransactions: async (assetId: string, sigType?: string, address?: string, notePrefix?: string, round?: string, txid?: string, txType?: string, currencyGreaterThan?: string, addressRole?: string, limit?: string, minRound?: string, excludeCloseTo?: string, maxRound?: string, rekeyTo?: string, beforeTime?: string, currencyLessThan?: string, afterTime?: string, next?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('lookupAssetTransactions', 'assetId', assetId)
            const localVarPath = `/v2/assets/{asset-id}/transactions`
                .replace(`{${"asset-id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (sigType !== undefined) {
                localVarQueryParameter['sig-type'] = sigType;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (notePrefix !== undefined) {
                localVarQueryParameter['note-prefix'] = notePrefix;
            }

            if (round !== undefined) {
                localVarQueryParameter['round'] = round;
            }

            if (txid !== undefined) {
                localVarQueryParameter['txid'] = txid;
            }

            if (txType !== undefined) {
                localVarQueryParameter['tx-type'] = txType;
            }

            if (currencyGreaterThan !== undefined) {
                localVarQueryParameter['currency-greater-than'] = currencyGreaterThan;
            }

            if (addressRole !== undefined) {
                localVarQueryParameter['address-role'] = addressRole;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (minRound !== undefined) {
                localVarQueryParameter['min-round'] = minRound;
            }

            if (excludeCloseTo !== undefined) {
                localVarQueryParameter['exclude-close-to'] = excludeCloseTo;
            }

            if (maxRound !== undefined) {
                localVarQueryParameter['max-round'] = maxRound;
            }

            if (rekeyTo !== undefined) {
                localVarQueryParameter['rekey-to'] = rekeyTo;
            }

            if (beforeTime !== undefined) {
                localVarQueryParameter['before-time'] = beforeTime;
            }

            if (currencyLessThan !== undefined) {
                localVarQueryParameter['currency-less-than'] = currencyLessThan;
            }

            if (afterTime !== undefined) {
                localVarQueryParameter['after-time'] = afterTime;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} roundNumber 
         * @param {string} [headerOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupBlock: async (roundNumber: string, headerOnly?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roundNumber' is not null or undefined
            assertParamExists('lookupBlock', 'roundNumber', roundNumber)
            const localVarPath = `/v2/blocks/{round-number}`
                .replace(`{${"round-number"}}`, encodeURIComponent(String(roundNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (headerOnly !== undefined) {
                localVarQueryParameter['header-only'] = headerOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} txid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupTransaction: async (txid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txid' is not null or undefined
            assertParamExists('lookupTransaction', 'txid', txid)
            const localVarPath = `/v2/transactions/{txid}`
                .replace(`{${"txid"}}`, encodeURIComponent(String(txid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeHealthCheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] 
         * @param {string} [assetId] 
         * @param {string} [authAddr] 
         * @param {string} [currencyLessThan] 
         * @param {string} [includeAll] 
         * @param {string} [applicationId] 
         * @param {string} [round] 
         * @param {string} [exclude] 
         * @param {string} [next] 
         * @param {string} [currencyGreaterThan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchForAccounts: async (limit?: string, assetId?: string, authAddr?: string, currencyLessThan?: string, includeAll?: string, applicationId?: string, round?: string, exclude?: string, next?: string, currencyGreaterThan?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset-id'] = assetId;
            }

            if (authAddr !== undefined) {
                localVarQueryParameter['auth-addr'] = authAddr;
            }

            if (currencyLessThan !== undefined) {
                localVarQueryParameter['currency-less-than'] = currencyLessThan;
            }

            if (includeAll !== undefined) {
                localVarQueryParameter['include-all'] = includeAll;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['application-id'] = applicationId;
            }

            if (round !== undefined) {
                localVarQueryParameter['round'] = round;
            }

            if (exclude !== undefined) {
                localVarQueryParameter['exclude'] = exclude;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (currencyGreaterThan !== undefined) {
                localVarQueryParameter['currency-greater-than'] = currencyGreaterThan;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [next] 
         * @param {string} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchForApplicationBoxes: async (applicationId: string, next?: string, limit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('searchForApplicationBoxes', 'applicationId', applicationId)
            const localVarPath = `/v2/applications/{application-id}/boxes`
                .replace(`{${"application-id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [creator] 
         * @param {string} [limit] 
         * @param {string} [applicationId] 
         * @param {string} [includeAll] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchForApplications: async (creator?: string, limit?: string, applicationId?: string, includeAll?: string, next?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (creator !== undefined) {
                localVarQueryParameter['creator'] = creator;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['application-id'] = applicationId;
            }

            if (includeAll !== undefined) {
                localVarQueryParameter['include-all'] = includeAll;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] 
         * @param {string} [assetId] 
         * @param {string} [name] 
         * @param {string} [unit] 
         * @param {string} [creator] 
         * @param {string} [includeAll] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchForAssets: async (limit?: string, assetId?: string, name?: string, unit?: string, creator?: string, includeAll?: string, next?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset-id'] = assetId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }

            if (creator !== undefined) {
                localVarQueryParameter['creator'] = creator;
            }

            if (includeAll !== undefined) {
                localVarQueryParameter['include-all'] = includeAll;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sigType] 
         * @param {string} [address] 
         * @param {string} [notePrefix] 
         * @param {string} [round] 
         * @param {string} [applicationId] 
         * @param {string} [txid] 
         * @param {string} [txType] 
         * @param {string} [currencyGreaterThan] 
         * @param {string} [addressRole] 
         * @param {string} [limit] 
         * @param {string} [minRound] 
         * @param {string} [assetId] 
         * @param {string} [excludeCloseTo] 
         * @param {string} [maxRound] 
         * @param {string} [rekeyTo] 
         * @param {string} [beforeTime] 
         * @param {string} [currencyLessThan] 
         * @param {string} [afterTime] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchForTransactions: async (sigType?: string, address?: string, notePrefix?: string, round?: string, applicationId?: string, txid?: string, txType?: string, currencyGreaterThan?: string, addressRole?: string, limit?: string, minRound?: string, assetId?: string, excludeCloseTo?: string, maxRound?: string, rekeyTo?: string, beforeTime?: string, currencyLessThan?: string, afterTime?: string, next?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (sigType !== undefined) {
                localVarQueryParameter['sig-type'] = sigType;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (notePrefix !== undefined) {
                localVarQueryParameter['note-prefix'] = notePrefix;
            }

            if (round !== undefined) {
                localVarQueryParameter['round'] = round;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['application-id'] = applicationId;
            }

            if (txid !== undefined) {
                localVarQueryParameter['txid'] = txid;
            }

            if (txType !== undefined) {
                localVarQueryParameter['tx-type'] = txType;
            }

            if (currencyGreaterThan !== undefined) {
                localVarQueryParameter['currency-greater-than'] = currencyGreaterThan;
            }

            if (addressRole !== undefined) {
                localVarQueryParameter['address-role'] = addressRole;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (minRound !== undefined) {
                localVarQueryParameter['min-round'] = minRound;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset-id'] = assetId;
            }

            if (excludeCloseTo !== undefined) {
                localVarQueryParameter['exclude-close-to'] = excludeCloseTo;
            }

            if (maxRound !== undefined) {
                localVarQueryParameter['max-round'] = maxRound;
            }

            if (rekeyTo !== undefined) {
                localVarQueryParameter['rekey-to'] = rekeyTo;
            }

            if (beforeTime !== undefined) {
                localVarQueryParameter['before-time'] = beforeTime;
            }

            if (currencyLessThan !== undefined) {
                localVarQueryParameter['currency-less-than'] = currencyLessThan;
            }

            if (afterTime !== undefined) {
                localVarQueryParameter['after-time'] = afterTime;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swaggerJSON: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/swagger.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swaggerJsonOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/swagger.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsAccountIdAppsLocalStateOptions: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('v2AccountsAccountIdAppsLocalStateOptions', 'accountId', accountId)
            const localVarPath = `/v2/accounts/{account-id}/apps-local-state`
                .replace(`{${"account-id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsAccountIdAssetsOptions: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('v2AccountsAccountIdAssetsOptions', 'accountId', accountId)
            const localVarPath = `/v2/accounts/{account-id}/assets`
                .replace(`{${"account-id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsAccountIdCreatedApplicationsOptions: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('v2AccountsAccountIdCreatedApplicationsOptions', 'accountId', accountId)
            const localVarPath = `/v2/accounts/{account-id}/created-applications`
                .replace(`{${"account-id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsAccountIdCreatedAssetsOptions: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('v2AccountsAccountIdCreatedAssetsOptions', 'accountId', accountId)
            const localVarPath = `/v2/accounts/{account-id}/created-assets`
                .replace(`{${"account-id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsAccountIdOptions: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('v2AccountsAccountIdOptions', 'accountId', accountId)
            const localVarPath = `/v2/accounts/{account-id}`
                .replace(`{${"account-id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsAccountIdTransactionsOptions: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('v2AccountsAccountIdTransactionsOptions', 'accountId', accountId)
            const localVarPath = `/v2/accounts/{account-id}/transactions`
                .replace(`{${"account-id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ApplicationsApplicationIdBoxOptions: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('v2ApplicationsApplicationIdBoxOptions', 'applicationId', applicationId)
            const localVarPath = `/v2/applications/{application-id}/box`
                .replace(`{${"application-id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ApplicationsApplicationIdBoxesOptions: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('v2ApplicationsApplicationIdBoxesOptions', 'applicationId', applicationId)
            const localVarPath = `/v2/applications/{application-id}/boxes`
                .replace(`{${"application-id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ApplicationsApplicationIdLogsOptions: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('v2ApplicationsApplicationIdLogsOptions', 'applicationId', applicationId)
            const localVarPath = `/v2/applications/{application-id}/logs`
                .replace(`{${"application-id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ApplicationsApplicationIdOptions: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('v2ApplicationsApplicationIdOptions', 'applicationId', applicationId)
            const localVarPath = `/v2/applications/{application-id}`
                .replace(`{${"application-id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ApplicationsOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AssetsAssetIdBalancesOptions: async (assetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('v2AssetsAssetIdBalancesOptions', 'assetId', assetId)
            const localVarPath = `/v2/assets/{asset-id}/balances`
                .replace(`{${"asset-id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AssetsAssetIdOptions: async (assetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('v2AssetsAssetIdOptions', 'assetId', assetId)
            const localVarPath = `/v2/assets/{asset-id}`
                .replace(`{${"asset-id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AssetsAssetIdTransactionsOptions: async (assetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('v2AssetsAssetIdTransactionsOptions', 'assetId', assetId)
            const localVarPath = `/v2/assets/{asset-id}/transactions`
                .replace(`{${"asset-id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AssetsOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} roundNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2BlocksRoundNumberOptions: async (roundNumber: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roundNumber' is not null or undefined
            assertParamExists('v2BlocksRoundNumberOptions', 'roundNumber', roundNumber)
            const localVarPath = `/v2/blocks/{round-number}`
                .replace(`{${"round-number"}}`, encodeURIComponent(String(roundNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TransactionsOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} txid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TransactionsTxidOptions: async (txid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txid' is not null or undefined
            assertParamExists('v2TransactionsTxidOptions', 'txid', txid)
            const localVarPath = `/v2/transactions/{txid}`
                .replace(`{${"txid"}}`, encodeURIComponent(String(txid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} [limit] 
         * @param {string} [applicationId] 
         * @param {string} [includeAll] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupAccountAppLocalStates(accountId: string, limit?: string, applicationId?: string, includeAll?: string, next?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupAccountAppLocalStates(accountId, limit, applicationId, includeAll, next, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} [limit] 
         * @param {string} [includeAll] 
         * @param {string} [assetId] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupAccountAssets(accountId: string, limit?: string, includeAll?: string, assetId?: string, next?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupAccountAssets(accountId, limit, includeAll, assetId, next, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} [round] 
         * @param {string} [includeAll] 
         * @param {string} [exclude] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupAccountByID(accountId: string, round?: string, includeAll?: string, exclude?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupAccountByID(accountId, round, includeAll, exclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} [limit] 
         * @param {string} [applicationId] 
         * @param {string} [includeAll] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupAccountCreatedApplications(accountId: string, limit?: string, applicationId?: string, includeAll?: string, next?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupAccountCreatedApplications(accountId, limit, applicationId, includeAll, next, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} [limit] 
         * @param {string} [includeAll] 
         * @param {string} [assetId] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupAccountCreatedAssets(accountId: string, limit?: string, includeAll?: string, assetId?: string, next?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupAccountCreatedAssets(accountId, limit, includeAll, assetId, next, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} [sigType] 
         * @param {string} [notePrefix] 
         * @param {string} [round] 
         * @param {string} [txid] 
         * @param {string} [txType] 
         * @param {string} [currencyGreaterThan] 
         * @param {string} [limit] 
         * @param {string} [minRound] 
         * @param {string} [assetId] 
         * @param {string} [maxRound] 
         * @param {string} [rekeyTo] 
         * @param {string} [beforeTime] 
         * @param {string} [currencyLessThan] 
         * @param {string} [afterTime] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupAccountTransactions(accountId: string, sigType?: string, notePrefix?: string, round?: string, txid?: string, txType?: string, currencyGreaterThan?: string, limit?: string, minRound?: string, assetId?: string, maxRound?: string, rekeyTo?: string, beforeTime?: string, currencyLessThan?: string, afterTime?: string, next?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupAccountTransactions(accountId, sigType, notePrefix, round, txid, txType, currencyGreaterThan, limit, minRound, assetId, maxRound, rekeyTo, beforeTime, currencyLessThan, afterTime, next, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupApplicationBoxByIDAndName(applicationId: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupApplicationBoxByIDAndName(applicationId, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [includeAll] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupApplicationByID(applicationId: string, includeAll?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupApplicationByID(applicationId, includeAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [limit] 
         * @param {string} [minRound] 
         * @param {string} [senderAddress] 
         * @param {string} [maxRound] 
         * @param {string} [txid] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupApplicationLogsByID(applicationId: string, limit?: string, minRound?: string, senderAddress?: string, maxRound?: string, txid?: string, next?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationLogsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupApplicationLogsByID(applicationId, limit, minRound, senderAddress, maxRound, txid, next, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} assetId 
         * @param {string} [currencyLessThan] 
         * @param {string} [limit] 
         * @param {string} [includeAll] 
         * @param {string} [next] 
         * @param {string} [currencyGreaterThan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupAssetBalances(assetId: string, currencyLessThan?: string, limit?: string, includeAll?: string, next?: string, currencyGreaterThan?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupAssetBalances(assetId, currencyLessThan, limit, includeAll, next, currencyGreaterThan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} assetId 
         * @param {string} [includeAll] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupAssetByID(assetId: string, includeAll?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupAssetByID(assetId, includeAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} assetId 
         * @param {string} [sigType] 
         * @param {string} [address] 
         * @param {string} [notePrefix] 
         * @param {string} [round] 
         * @param {string} [txid] 
         * @param {string} [txType] 
         * @param {string} [currencyGreaterThan] 
         * @param {string} [addressRole] 
         * @param {string} [limit] 
         * @param {string} [minRound] 
         * @param {string} [excludeCloseTo] 
         * @param {string} [maxRound] 
         * @param {string} [rekeyTo] 
         * @param {string} [beforeTime] 
         * @param {string} [currencyLessThan] 
         * @param {string} [afterTime] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupAssetTransactions(assetId: string, sigType?: string, address?: string, notePrefix?: string, round?: string, txid?: string, txType?: string, currencyGreaterThan?: string, addressRole?: string, limit?: string, minRound?: string, excludeCloseTo?: string, maxRound?: string, rekeyTo?: string, beforeTime?: string, currencyLessThan?: string, afterTime?: string, next?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupAssetTransactions(assetId, sigType, address, notePrefix, round, txid, txType, currencyGreaterThan, addressRole, limit, minRound, excludeCloseTo, maxRound, rekeyTo, beforeTime, currencyLessThan, afterTime, next, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} roundNumber 
         * @param {string} [headerOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupBlock(roundNumber: string, headerOnly?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Block>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupBlock(roundNumber, headerOnly, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} txid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupTransaction(txid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupTransaction(txid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async makeHealthCheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.makeHealthCheck(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] 
         * @param {string} [assetId] 
         * @param {string} [authAddr] 
         * @param {string} [currencyLessThan] 
         * @param {string} [includeAll] 
         * @param {string} [applicationId] 
         * @param {string} [round] 
         * @param {string} [exclude] 
         * @param {string} [next] 
         * @param {string} [currencyGreaterThan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchForAccounts(limit?: string, assetId?: string, authAddr?: string, currencyLessThan?: string, includeAll?: string, applicationId?: string, round?: string, exclude?: string, next?: string, currencyGreaterThan?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchForAccounts(limit, assetId, authAddr, currencyLessThan, includeAll, applicationId, round, exclude, next, currencyGreaterThan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [next] 
         * @param {string} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchForApplicationBoxes(applicationId: string, next?: string, limit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchForApplicationBoxes(applicationId, next, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [creator] 
         * @param {string} [limit] 
         * @param {string} [applicationId] 
         * @param {string} [includeAll] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchForApplications(creator?: string, limit?: string, applicationId?: string, includeAll?: string, next?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchForApplications(creator, limit, applicationId, includeAll, next, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] 
         * @param {string} [assetId] 
         * @param {string} [name] 
         * @param {string} [unit] 
         * @param {string} [creator] 
         * @param {string} [includeAll] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchForAssets(limit?: string, assetId?: string, name?: string, unit?: string, creator?: string, includeAll?: string, next?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchForAssets(limit, assetId, name, unit, creator, includeAll, next, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [sigType] 
         * @param {string} [address] 
         * @param {string} [notePrefix] 
         * @param {string} [round] 
         * @param {string} [applicationId] 
         * @param {string} [txid] 
         * @param {string} [txType] 
         * @param {string} [currencyGreaterThan] 
         * @param {string} [addressRole] 
         * @param {string} [limit] 
         * @param {string} [minRound] 
         * @param {string} [assetId] 
         * @param {string} [excludeCloseTo] 
         * @param {string} [maxRound] 
         * @param {string} [rekeyTo] 
         * @param {string} [beforeTime] 
         * @param {string} [currencyLessThan] 
         * @param {string} [afterTime] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchForTransactions(sigType?: string, address?: string, notePrefix?: string, round?: string, applicationId?: string, txid?: string, txType?: string, currencyGreaterThan?: string, addressRole?: string, limit?: string, minRound?: string, assetId?: string, excludeCloseTo?: string, maxRound?: string, rekeyTo?: string, beforeTime?: string, currencyLessThan?: string, afterTime?: string, next?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchForTransactions(sigType, address, notePrefix, round, applicationId, txid, txType, currencyGreaterThan, addressRole, limit, minRound, assetId, excludeCloseTo, maxRound, rekeyTo, beforeTime, currencyLessThan, afterTime, next, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async swaggerJSON(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.swaggerJSON(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async swaggerJsonOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.swaggerJsonOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AccountsAccountIdAppsLocalStateOptions(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AccountsAccountIdAppsLocalStateOptions(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AccountsAccountIdAssetsOptions(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AccountsAccountIdAssetsOptions(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AccountsAccountIdCreatedApplicationsOptions(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AccountsAccountIdCreatedApplicationsOptions(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AccountsAccountIdCreatedAssetsOptions(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AccountsAccountIdCreatedAssetsOptions(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AccountsAccountIdOptions(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AccountsAccountIdOptions(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AccountsAccountIdTransactionsOptions(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AccountsAccountIdTransactionsOptions(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AccountsOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AccountsOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2ApplicationsApplicationIdBoxOptions(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2ApplicationsApplicationIdBoxOptions(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2ApplicationsApplicationIdBoxesOptions(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2ApplicationsApplicationIdBoxesOptions(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2ApplicationsApplicationIdLogsOptions(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2ApplicationsApplicationIdLogsOptions(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2ApplicationsApplicationIdOptions(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2ApplicationsApplicationIdOptions(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2ApplicationsOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2ApplicationsOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AssetsAssetIdBalancesOptions(assetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AssetsAssetIdBalancesOptions(assetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AssetsAssetIdOptions(assetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AssetsAssetIdOptions(assetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AssetsAssetIdTransactionsOptions(assetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AssetsAssetIdTransactionsOptions(assetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AssetsOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AssetsOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} roundNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2BlocksRoundNumberOptions(roundNumber: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2BlocksRoundNumberOptions(roundNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2TransactionsOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2TransactionsOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} txid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2TransactionsTxidOptions(txid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2TransactionsTxidOptions(txid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthOptions(options?: any): AxiosPromise<void> {
            return localVarFp.healthOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} [limit] 
         * @param {string} [applicationId] 
         * @param {string} [includeAll] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAccountAppLocalStates(accountId: string, limit?: string, applicationId?: string, includeAll?: string, next?: string, options?: any): AxiosPromise<object> {
            return localVarFp.lookupAccountAppLocalStates(accountId, limit, applicationId, includeAll, next, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} [limit] 
         * @param {string} [includeAll] 
         * @param {string} [assetId] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAccountAssets(accountId: string, limit?: string, includeAll?: string, assetId?: string, next?: string, options?: any): AxiosPromise<object> {
            return localVarFp.lookupAccountAssets(accountId, limit, includeAll, assetId, next, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} [round] 
         * @param {string} [includeAll] 
         * @param {string} [exclude] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAccountByID(accountId: string, round?: string, includeAll?: string, exclude?: string, options?: any): AxiosPromise<AccountResponse> {
            return localVarFp.lookupAccountByID(accountId, round, includeAll, exclude, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} [limit] 
         * @param {string} [applicationId] 
         * @param {string} [includeAll] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAccountCreatedApplications(accountId: string, limit?: string, applicationId?: string, includeAll?: string, next?: string, options?: any): AxiosPromise<ApplicationsResponse> {
            return localVarFp.lookupAccountCreatedApplications(accountId, limit, applicationId, includeAll, next, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} [limit] 
         * @param {string} [includeAll] 
         * @param {string} [assetId] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAccountCreatedAssets(accountId: string, limit?: string, includeAll?: string, assetId?: string, next?: string, options?: any): AxiosPromise<AssetsResponse> {
            return localVarFp.lookupAccountCreatedAssets(accountId, limit, includeAll, assetId, next, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} [sigType] 
         * @param {string} [notePrefix] 
         * @param {string} [round] 
         * @param {string} [txid] 
         * @param {string} [txType] 
         * @param {string} [currencyGreaterThan] 
         * @param {string} [limit] 
         * @param {string} [minRound] 
         * @param {string} [assetId] 
         * @param {string} [maxRound] 
         * @param {string} [rekeyTo] 
         * @param {string} [beforeTime] 
         * @param {string} [currencyLessThan] 
         * @param {string} [afterTime] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAccountTransactions(accountId: string, sigType?: string, notePrefix?: string, round?: string, txid?: string, txType?: string, currencyGreaterThan?: string, limit?: string, minRound?: string, assetId?: string, maxRound?: string, rekeyTo?: string, beforeTime?: string, currencyLessThan?: string, afterTime?: string, next?: string, options?: any): AxiosPromise<TransactionsResponse> {
            return localVarFp.lookupAccountTransactions(accountId, sigType, notePrefix, round, txid, txType, currencyGreaterThan, limit, minRound, assetId, maxRound, rekeyTo, beforeTime, currencyLessThan, afterTime, next, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupApplicationBoxByIDAndName(applicationId: string, name: string, options?: any): AxiosPromise<object> {
            return localVarFp.lookupApplicationBoxByIDAndName(applicationId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [includeAll] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupApplicationByID(applicationId: string, includeAll?: string, options?: any): AxiosPromise<ApplicationResponse> {
            return localVarFp.lookupApplicationByID(applicationId, includeAll, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [limit] 
         * @param {string} [minRound] 
         * @param {string} [senderAddress] 
         * @param {string} [maxRound] 
         * @param {string} [txid] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupApplicationLogsByID(applicationId: string, limit?: string, minRound?: string, senderAddress?: string, maxRound?: string, txid?: string, next?: string, options?: any): AxiosPromise<ApplicationLogsResponse> {
            return localVarFp.lookupApplicationLogsByID(applicationId, limit, minRound, senderAddress, maxRound, txid, next, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} assetId 
         * @param {string} [currencyLessThan] 
         * @param {string} [limit] 
         * @param {string} [includeAll] 
         * @param {string} [next] 
         * @param {string} [currencyGreaterThan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAssetBalances(assetId: string, currencyLessThan?: string, limit?: string, includeAll?: string, next?: string, currencyGreaterThan?: string, options?: any): AxiosPromise<AssetBalanceResponse> {
            return localVarFp.lookupAssetBalances(assetId, currencyLessThan, limit, includeAll, next, currencyGreaterThan, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} assetId 
         * @param {string} [includeAll] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAssetByID(assetId: string, includeAll?: string, options?: any): AxiosPromise<AssetResponse> {
            return localVarFp.lookupAssetByID(assetId, includeAll, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} assetId 
         * @param {string} [sigType] 
         * @param {string} [address] 
         * @param {string} [notePrefix] 
         * @param {string} [round] 
         * @param {string} [txid] 
         * @param {string} [txType] 
         * @param {string} [currencyGreaterThan] 
         * @param {string} [addressRole] 
         * @param {string} [limit] 
         * @param {string} [minRound] 
         * @param {string} [excludeCloseTo] 
         * @param {string} [maxRound] 
         * @param {string} [rekeyTo] 
         * @param {string} [beforeTime] 
         * @param {string} [currencyLessThan] 
         * @param {string} [afterTime] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAssetTransactions(assetId: string, sigType?: string, address?: string, notePrefix?: string, round?: string, txid?: string, txType?: string, currencyGreaterThan?: string, addressRole?: string, limit?: string, minRound?: string, excludeCloseTo?: string, maxRound?: string, rekeyTo?: string, beforeTime?: string, currencyLessThan?: string, afterTime?: string, next?: string, options?: any): AxiosPromise<TransactionsResponse> {
            return localVarFp.lookupAssetTransactions(assetId, sigType, address, notePrefix, round, txid, txType, currencyGreaterThan, addressRole, limit, minRound, excludeCloseTo, maxRound, rekeyTo, beforeTime, currencyLessThan, afterTime, next, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} roundNumber 
         * @param {string} [headerOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupBlock(roundNumber: string, headerOnly?: string, options?: any): AxiosPromise<Block> {
            return localVarFp.lookupBlock(roundNumber, headerOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} txid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupTransaction(txid: string, options?: any): AxiosPromise<TransactionResponse> {
            return localVarFp.lookupTransaction(txid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeHealthCheck(options?: any): AxiosPromise<HealthCheckResponse> {
            return localVarFp.makeHealthCheck(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] 
         * @param {string} [assetId] 
         * @param {string} [authAddr] 
         * @param {string} [currencyLessThan] 
         * @param {string} [includeAll] 
         * @param {string} [applicationId] 
         * @param {string} [round] 
         * @param {string} [exclude] 
         * @param {string} [next] 
         * @param {string} [currencyGreaterThan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchForAccounts(limit?: string, assetId?: string, authAddr?: string, currencyLessThan?: string, includeAll?: string, applicationId?: string, round?: string, exclude?: string, next?: string, currencyGreaterThan?: string, options?: any): AxiosPromise<AccountsResponse> {
            return localVarFp.searchForAccounts(limit, assetId, authAddr, currencyLessThan, includeAll, applicationId, round, exclude, next, currencyGreaterThan, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [next] 
         * @param {string} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchForApplicationBoxes(applicationId: string, next?: string, limit?: string, options?: any): AxiosPromise<object> {
            return localVarFp.searchForApplicationBoxes(applicationId, next, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [creator] 
         * @param {string} [limit] 
         * @param {string} [applicationId] 
         * @param {string} [includeAll] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchForApplications(creator?: string, limit?: string, applicationId?: string, includeAll?: string, next?: string, options?: any): AxiosPromise<ApplicationsResponse> {
            return localVarFp.searchForApplications(creator, limit, applicationId, includeAll, next, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] 
         * @param {string} [assetId] 
         * @param {string} [name] 
         * @param {string} [unit] 
         * @param {string} [creator] 
         * @param {string} [includeAll] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchForAssets(limit?: string, assetId?: string, name?: string, unit?: string, creator?: string, includeAll?: string, next?: string, options?: any): AxiosPromise<AssetsResponse> {
            return localVarFp.searchForAssets(limit, assetId, name, unit, creator, includeAll, next, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [sigType] 
         * @param {string} [address] 
         * @param {string} [notePrefix] 
         * @param {string} [round] 
         * @param {string} [applicationId] 
         * @param {string} [txid] 
         * @param {string} [txType] 
         * @param {string} [currencyGreaterThan] 
         * @param {string} [addressRole] 
         * @param {string} [limit] 
         * @param {string} [minRound] 
         * @param {string} [assetId] 
         * @param {string} [excludeCloseTo] 
         * @param {string} [maxRound] 
         * @param {string} [rekeyTo] 
         * @param {string} [beforeTime] 
         * @param {string} [currencyLessThan] 
         * @param {string} [afterTime] 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchForTransactions(sigType?: string, address?: string, notePrefix?: string, round?: string, applicationId?: string, txid?: string, txType?: string, currencyGreaterThan?: string, addressRole?: string, limit?: string, minRound?: string, assetId?: string, excludeCloseTo?: string, maxRound?: string, rekeyTo?: string, beforeTime?: string, currencyLessThan?: string, afterTime?: string, next?: string, options?: any): AxiosPromise<TransactionsResponse> {
            return localVarFp.searchForTransactions(sigType, address, notePrefix, round, applicationId, txid, txType, currencyGreaterThan, addressRole, limit, minRound, assetId, excludeCloseTo, maxRound, rekeyTo, beforeTime, currencyLessThan, afterTime, next, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swaggerJSON(options?: any): AxiosPromise<void> {
            return localVarFp.swaggerJSON(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swaggerJsonOptions(options?: any): AxiosPromise<void> {
            return localVarFp.swaggerJsonOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsAccountIdAppsLocalStateOptions(accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2AccountsAccountIdAppsLocalStateOptions(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsAccountIdAssetsOptions(accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2AccountsAccountIdAssetsOptions(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsAccountIdCreatedApplicationsOptions(accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2AccountsAccountIdCreatedApplicationsOptions(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsAccountIdCreatedAssetsOptions(accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2AccountsAccountIdCreatedAssetsOptions(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsAccountIdOptions(accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2AccountsAccountIdOptions(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsAccountIdTransactionsOptions(accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2AccountsAccountIdTransactionsOptions(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccountsOptions(options?: any): AxiosPromise<void> {
            return localVarFp.v2AccountsOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ApplicationsApplicationIdBoxOptions(applicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2ApplicationsApplicationIdBoxOptions(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ApplicationsApplicationIdBoxesOptions(applicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2ApplicationsApplicationIdBoxesOptions(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ApplicationsApplicationIdLogsOptions(applicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2ApplicationsApplicationIdLogsOptions(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ApplicationsApplicationIdOptions(applicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2ApplicationsApplicationIdOptions(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ApplicationsOptions(options?: any): AxiosPromise<void> {
            return localVarFp.v2ApplicationsOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AssetsAssetIdBalancesOptions(assetId: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2AssetsAssetIdBalancesOptions(assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AssetsAssetIdOptions(assetId: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2AssetsAssetIdOptions(assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AssetsAssetIdTransactionsOptions(assetId: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2AssetsAssetIdTransactionsOptions(assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AssetsOptions(options?: any): AxiosPromise<void> {
            return localVarFp.v2AssetsOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} roundNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2BlocksRoundNumberOptions(roundNumber: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2BlocksRoundNumberOptions(roundNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TransactionsOptions(options?: any): AxiosPromise<void> {
            return localVarFp.v2TransactionsOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} txid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TransactionsTxidOptions(txid: string, options?: any): AxiosPromise<void> {
            return localVarFp.v2TransactionsTxidOptions(txid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    healthOptions(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} accountId 
     * @param {string} [limit] 
     * @param {string} [applicationId] 
     * @param {string} [includeAll] 
     * @param {string} [next] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    lookupAccountAppLocalStates(accountId: string, limit?: string, applicationId?: string, includeAll?: string, next?: string, options?: AxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @param {string} accountId 
     * @param {string} [limit] 
     * @param {string} [includeAll] 
     * @param {string} [assetId] 
     * @param {string} [next] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    lookupAccountAssets(accountId: string, limit?: string, includeAll?: string, assetId?: string, next?: string, options?: AxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @param {string} accountId 
     * @param {string} [round] 
     * @param {string} [includeAll] 
     * @param {string} [exclude] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    lookupAccountByID(accountId: string, round?: string, includeAll?: string, exclude?: string, options?: AxiosRequestConfig): AxiosPromise<AccountResponse>;

    /**
     * 
     * @param {string} accountId 
     * @param {string} [limit] 
     * @param {string} [applicationId] 
     * @param {string} [includeAll] 
     * @param {string} [next] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    lookupAccountCreatedApplications(accountId: string, limit?: string, applicationId?: string, includeAll?: string, next?: string, options?: AxiosRequestConfig): AxiosPromise<ApplicationsResponse>;

    /**
     * 
     * @param {string} accountId 
     * @param {string} [limit] 
     * @param {string} [includeAll] 
     * @param {string} [assetId] 
     * @param {string} [next] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    lookupAccountCreatedAssets(accountId: string, limit?: string, includeAll?: string, assetId?: string, next?: string, options?: AxiosRequestConfig): AxiosPromise<AssetsResponse>;

    /**
     * 
     * @param {string} accountId 
     * @param {string} [sigType] 
     * @param {string} [notePrefix] 
     * @param {string} [round] 
     * @param {string} [txid] 
     * @param {string} [txType] 
     * @param {string} [currencyGreaterThan] 
     * @param {string} [limit] 
     * @param {string} [minRound] 
     * @param {string} [assetId] 
     * @param {string} [maxRound] 
     * @param {string} [rekeyTo] 
     * @param {string} [beforeTime] 
     * @param {string} [currencyLessThan] 
     * @param {string} [afterTime] 
     * @param {string} [next] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    lookupAccountTransactions(accountId: string, sigType?: string, notePrefix?: string, round?: string, txid?: string, txType?: string, currencyGreaterThan?: string, limit?: string, minRound?: string, assetId?: string, maxRound?: string, rekeyTo?: string, beforeTime?: string, currencyLessThan?: string, afterTime?: string, next?: string, options?: AxiosRequestConfig): AxiosPromise<TransactionsResponse>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    lookupApplicationBoxByIDAndName(applicationId: string, name: string, options?: AxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} [includeAll] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    lookupApplicationByID(applicationId: string, includeAll?: string, options?: AxiosRequestConfig): AxiosPromise<ApplicationResponse>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} [limit] 
     * @param {string} [minRound] 
     * @param {string} [senderAddress] 
     * @param {string} [maxRound] 
     * @param {string} [txid] 
     * @param {string} [next] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    lookupApplicationLogsByID(applicationId: string, limit?: string, minRound?: string, senderAddress?: string, maxRound?: string, txid?: string, next?: string, options?: AxiosRequestConfig): AxiosPromise<ApplicationLogsResponse>;

    /**
     * 
     * @param {string} assetId 
     * @param {string} [currencyLessThan] 
     * @param {string} [limit] 
     * @param {string} [includeAll] 
     * @param {string} [next] 
     * @param {string} [currencyGreaterThan] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    lookupAssetBalances(assetId: string, currencyLessThan?: string, limit?: string, includeAll?: string, next?: string, currencyGreaterThan?: string, options?: AxiosRequestConfig): AxiosPromise<AssetBalanceResponse>;

    /**
     * 
     * @param {string} assetId 
     * @param {string} [includeAll] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    lookupAssetByID(assetId: string, includeAll?: string, options?: AxiosRequestConfig): AxiosPromise<AssetResponse>;

    /**
     * 
     * @param {string} assetId 
     * @param {string} [sigType] 
     * @param {string} [address] 
     * @param {string} [notePrefix] 
     * @param {string} [round] 
     * @param {string} [txid] 
     * @param {string} [txType] 
     * @param {string} [currencyGreaterThan] 
     * @param {string} [addressRole] 
     * @param {string} [limit] 
     * @param {string} [minRound] 
     * @param {string} [excludeCloseTo] 
     * @param {string} [maxRound] 
     * @param {string} [rekeyTo] 
     * @param {string} [beforeTime] 
     * @param {string} [currencyLessThan] 
     * @param {string} [afterTime] 
     * @param {string} [next] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    lookupAssetTransactions(assetId: string, sigType?: string, address?: string, notePrefix?: string, round?: string, txid?: string, txType?: string, currencyGreaterThan?: string, addressRole?: string, limit?: string, minRound?: string, excludeCloseTo?: string, maxRound?: string, rekeyTo?: string, beforeTime?: string, currencyLessThan?: string, afterTime?: string, next?: string, options?: AxiosRequestConfig): AxiosPromise<TransactionsResponse>;

    /**
     * 
     * @param {string} roundNumber 
     * @param {string} [headerOnly] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    lookupBlock(roundNumber: string, headerOnly?: string, options?: AxiosRequestConfig): AxiosPromise<Block>;

    /**
     * 
     * @param {string} txid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    lookupTransaction(txid: string, options?: AxiosRequestConfig): AxiosPromise<TransactionResponse>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    makeHealthCheck(options?: AxiosRequestConfig): AxiosPromise<HealthCheckResponse>;

    /**
     * 
     * @param {string} [limit] 
     * @param {string} [assetId] 
     * @param {string} [authAddr] 
     * @param {string} [currencyLessThan] 
     * @param {string} [includeAll] 
     * @param {string} [applicationId] 
     * @param {string} [round] 
     * @param {string} [exclude] 
     * @param {string} [next] 
     * @param {string} [currencyGreaterThan] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    searchForAccounts(limit?: string, assetId?: string, authAddr?: string, currencyLessThan?: string, includeAll?: string, applicationId?: string, round?: string, exclude?: string, next?: string, currencyGreaterThan?: string, options?: AxiosRequestConfig): AxiosPromise<AccountsResponse>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} [next] 
     * @param {string} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    searchForApplicationBoxes(applicationId: string, next?: string, limit?: string, options?: AxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @param {string} [creator] 
     * @param {string} [limit] 
     * @param {string} [applicationId] 
     * @param {string} [includeAll] 
     * @param {string} [next] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    searchForApplications(creator?: string, limit?: string, applicationId?: string, includeAll?: string, next?: string, options?: AxiosRequestConfig): AxiosPromise<ApplicationsResponse>;

    /**
     * 
     * @param {string} [limit] 
     * @param {string} [assetId] 
     * @param {string} [name] 
     * @param {string} [unit] 
     * @param {string} [creator] 
     * @param {string} [includeAll] 
     * @param {string} [next] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    searchForAssets(limit?: string, assetId?: string, name?: string, unit?: string, creator?: string, includeAll?: string, next?: string, options?: AxiosRequestConfig): AxiosPromise<AssetsResponse>;

    /**
     * 
     * @param {string} [sigType] 
     * @param {string} [address] 
     * @param {string} [notePrefix] 
     * @param {string} [round] 
     * @param {string} [applicationId] 
     * @param {string} [txid] 
     * @param {string} [txType] 
     * @param {string} [currencyGreaterThan] 
     * @param {string} [addressRole] 
     * @param {string} [limit] 
     * @param {string} [minRound] 
     * @param {string} [assetId] 
     * @param {string} [excludeCloseTo] 
     * @param {string} [maxRound] 
     * @param {string} [rekeyTo] 
     * @param {string} [beforeTime] 
     * @param {string} [currencyLessThan] 
     * @param {string} [afterTime] 
     * @param {string} [next] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    searchForTransactions(sigType?: string, address?: string, notePrefix?: string, round?: string, applicationId?: string, txid?: string, txType?: string, currencyGreaterThan?: string, addressRole?: string, limit?: string, minRound?: string, assetId?: string, excludeCloseTo?: string, maxRound?: string, rekeyTo?: string, beforeTime?: string, currencyLessThan?: string, afterTime?: string, next?: string, options?: AxiosRequestConfig): AxiosPromise<TransactionsResponse>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    swaggerJSON(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    swaggerJsonOptions(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2AccountsAccountIdAppsLocalStateOptions(accountId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2AccountsAccountIdAssetsOptions(accountId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2AccountsAccountIdCreatedApplicationsOptions(accountId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2AccountsAccountIdCreatedAssetsOptions(accountId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2AccountsAccountIdOptions(accountId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2AccountsAccountIdTransactionsOptions(accountId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2AccountsOptions(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2ApplicationsApplicationIdBoxOptions(applicationId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2ApplicationsApplicationIdBoxesOptions(applicationId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2ApplicationsApplicationIdLogsOptions(applicationId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2ApplicationsApplicationIdOptions(applicationId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2ApplicationsOptions(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} assetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2AssetsAssetIdBalancesOptions(assetId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} assetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2AssetsAssetIdOptions(assetId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} assetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2AssetsAssetIdTransactionsOptions(assetId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2AssetsOptions(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} roundNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2BlocksRoundNumberOptions(roundNumber: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2TransactionsOptions(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} txid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    v2TransactionsTxidOptions(txid: string, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public healthOptions(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId 
     * @param {string} [limit] 
     * @param {string} [applicationId] 
     * @param {string} [includeAll] 
     * @param {string} [next] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lookupAccountAppLocalStates(accountId: string, limit?: string, applicationId?: string, includeAll?: string, next?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lookupAccountAppLocalStates(accountId, limit, applicationId, includeAll, next, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId 
     * @param {string} [limit] 
     * @param {string} [includeAll] 
     * @param {string} [assetId] 
     * @param {string} [next] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lookupAccountAssets(accountId: string, limit?: string, includeAll?: string, assetId?: string, next?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lookupAccountAssets(accountId, limit, includeAll, assetId, next, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId 
     * @param {string} [round] 
     * @param {string} [includeAll] 
     * @param {string} [exclude] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lookupAccountByID(accountId: string, round?: string, includeAll?: string, exclude?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lookupAccountByID(accountId, round, includeAll, exclude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId 
     * @param {string} [limit] 
     * @param {string} [applicationId] 
     * @param {string} [includeAll] 
     * @param {string} [next] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lookupAccountCreatedApplications(accountId: string, limit?: string, applicationId?: string, includeAll?: string, next?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lookupAccountCreatedApplications(accountId, limit, applicationId, includeAll, next, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId 
     * @param {string} [limit] 
     * @param {string} [includeAll] 
     * @param {string} [assetId] 
     * @param {string} [next] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lookupAccountCreatedAssets(accountId: string, limit?: string, includeAll?: string, assetId?: string, next?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lookupAccountCreatedAssets(accountId, limit, includeAll, assetId, next, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId 
     * @param {string} [sigType] 
     * @param {string} [notePrefix] 
     * @param {string} [round] 
     * @param {string} [txid] 
     * @param {string} [txType] 
     * @param {string} [currencyGreaterThan] 
     * @param {string} [limit] 
     * @param {string} [minRound] 
     * @param {string} [assetId] 
     * @param {string} [maxRound] 
     * @param {string} [rekeyTo] 
     * @param {string} [beforeTime] 
     * @param {string} [currencyLessThan] 
     * @param {string} [afterTime] 
     * @param {string} [next] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lookupAccountTransactions(accountId: string, sigType?: string, notePrefix?: string, round?: string, txid?: string, txType?: string, currencyGreaterThan?: string, limit?: string, minRound?: string, assetId?: string, maxRound?: string, rekeyTo?: string, beforeTime?: string, currencyLessThan?: string, afterTime?: string, next?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lookupAccountTransactions(accountId, sigType, notePrefix, round, txid, txType, currencyGreaterThan, limit, minRound, assetId, maxRound, rekeyTo, beforeTime, currencyLessThan, afterTime, next, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lookupApplicationBoxByIDAndName(applicationId: string, name: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lookupApplicationBoxByIDAndName(applicationId, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} [includeAll] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lookupApplicationByID(applicationId: string, includeAll?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lookupApplicationByID(applicationId, includeAll, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} [limit] 
     * @param {string} [minRound] 
     * @param {string} [senderAddress] 
     * @param {string} [maxRound] 
     * @param {string} [txid] 
     * @param {string} [next] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lookupApplicationLogsByID(applicationId: string, limit?: string, minRound?: string, senderAddress?: string, maxRound?: string, txid?: string, next?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lookupApplicationLogsByID(applicationId, limit, minRound, senderAddress, maxRound, txid, next, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} assetId 
     * @param {string} [currencyLessThan] 
     * @param {string} [limit] 
     * @param {string} [includeAll] 
     * @param {string} [next] 
     * @param {string} [currencyGreaterThan] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lookupAssetBalances(assetId: string, currencyLessThan?: string, limit?: string, includeAll?: string, next?: string, currencyGreaterThan?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lookupAssetBalances(assetId, currencyLessThan, limit, includeAll, next, currencyGreaterThan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} assetId 
     * @param {string} [includeAll] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lookupAssetByID(assetId: string, includeAll?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lookupAssetByID(assetId, includeAll, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} assetId 
     * @param {string} [sigType] 
     * @param {string} [address] 
     * @param {string} [notePrefix] 
     * @param {string} [round] 
     * @param {string} [txid] 
     * @param {string} [txType] 
     * @param {string} [currencyGreaterThan] 
     * @param {string} [addressRole] 
     * @param {string} [limit] 
     * @param {string} [minRound] 
     * @param {string} [excludeCloseTo] 
     * @param {string} [maxRound] 
     * @param {string} [rekeyTo] 
     * @param {string} [beforeTime] 
     * @param {string} [currencyLessThan] 
     * @param {string} [afterTime] 
     * @param {string} [next] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lookupAssetTransactions(assetId: string, sigType?: string, address?: string, notePrefix?: string, round?: string, txid?: string, txType?: string, currencyGreaterThan?: string, addressRole?: string, limit?: string, minRound?: string, excludeCloseTo?: string, maxRound?: string, rekeyTo?: string, beforeTime?: string, currencyLessThan?: string, afterTime?: string, next?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lookupAssetTransactions(assetId, sigType, address, notePrefix, round, txid, txType, currencyGreaterThan, addressRole, limit, minRound, excludeCloseTo, maxRound, rekeyTo, beforeTime, currencyLessThan, afterTime, next, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} roundNumber 
     * @param {string} [headerOnly] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lookupBlock(roundNumber: string, headerOnly?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lookupBlock(roundNumber, headerOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} txid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lookupTransaction(txid: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lookupTransaction(txid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public makeHealthCheck(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).makeHealthCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] 
     * @param {string} [assetId] 
     * @param {string} [authAddr] 
     * @param {string} [currencyLessThan] 
     * @param {string} [includeAll] 
     * @param {string} [applicationId] 
     * @param {string} [round] 
     * @param {string} [exclude] 
     * @param {string} [next] 
     * @param {string} [currencyGreaterThan] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public searchForAccounts(limit?: string, assetId?: string, authAddr?: string, currencyLessThan?: string, includeAll?: string, applicationId?: string, round?: string, exclude?: string, next?: string, currencyGreaterThan?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).searchForAccounts(limit, assetId, authAddr, currencyLessThan, includeAll, applicationId, round, exclude, next, currencyGreaterThan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} [next] 
     * @param {string} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public searchForApplicationBoxes(applicationId: string, next?: string, limit?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).searchForApplicationBoxes(applicationId, next, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [creator] 
     * @param {string} [limit] 
     * @param {string} [applicationId] 
     * @param {string} [includeAll] 
     * @param {string} [next] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public searchForApplications(creator?: string, limit?: string, applicationId?: string, includeAll?: string, next?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).searchForApplications(creator, limit, applicationId, includeAll, next, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] 
     * @param {string} [assetId] 
     * @param {string} [name] 
     * @param {string} [unit] 
     * @param {string} [creator] 
     * @param {string} [includeAll] 
     * @param {string} [next] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public searchForAssets(limit?: string, assetId?: string, name?: string, unit?: string, creator?: string, includeAll?: string, next?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).searchForAssets(limit, assetId, name, unit, creator, includeAll, next, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [sigType] 
     * @param {string} [address] 
     * @param {string} [notePrefix] 
     * @param {string} [round] 
     * @param {string} [applicationId] 
     * @param {string} [txid] 
     * @param {string} [txType] 
     * @param {string} [currencyGreaterThan] 
     * @param {string} [addressRole] 
     * @param {string} [limit] 
     * @param {string} [minRound] 
     * @param {string} [assetId] 
     * @param {string} [excludeCloseTo] 
     * @param {string} [maxRound] 
     * @param {string} [rekeyTo] 
     * @param {string} [beforeTime] 
     * @param {string} [currencyLessThan] 
     * @param {string} [afterTime] 
     * @param {string} [next] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public searchForTransactions(sigType?: string, address?: string, notePrefix?: string, round?: string, applicationId?: string, txid?: string, txType?: string, currencyGreaterThan?: string, addressRole?: string, limit?: string, minRound?: string, assetId?: string, excludeCloseTo?: string, maxRound?: string, rekeyTo?: string, beforeTime?: string, currencyLessThan?: string, afterTime?: string, next?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).searchForTransactions(sigType, address, notePrefix, round, applicationId, txid, txType, currencyGreaterThan, addressRole, limit, minRound, assetId, excludeCloseTo, maxRound, rekeyTo, beforeTime, currencyLessThan, afterTime, next, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public swaggerJSON(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).swaggerJSON(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public swaggerJsonOptions(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).swaggerJsonOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AccountsAccountIdAppsLocalStateOptions(accountId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AccountsAccountIdAppsLocalStateOptions(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AccountsAccountIdAssetsOptions(accountId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AccountsAccountIdAssetsOptions(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AccountsAccountIdCreatedApplicationsOptions(accountId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AccountsAccountIdCreatedApplicationsOptions(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AccountsAccountIdCreatedAssetsOptions(accountId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AccountsAccountIdCreatedAssetsOptions(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AccountsAccountIdOptions(accountId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AccountsAccountIdOptions(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AccountsAccountIdTransactionsOptions(accountId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AccountsAccountIdTransactionsOptions(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AccountsOptions(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AccountsOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2ApplicationsApplicationIdBoxOptions(applicationId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2ApplicationsApplicationIdBoxOptions(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2ApplicationsApplicationIdBoxesOptions(applicationId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2ApplicationsApplicationIdBoxesOptions(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2ApplicationsApplicationIdLogsOptions(applicationId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2ApplicationsApplicationIdLogsOptions(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2ApplicationsApplicationIdOptions(applicationId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2ApplicationsApplicationIdOptions(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2ApplicationsOptions(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2ApplicationsOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} assetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AssetsAssetIdBalancesOptions(assetId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AssetsAssetIdBalancesOptions(assetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} assetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AssetsAssetIdOptions(assetId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AssetsAssetIdOptions(assetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} assetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AssetsAssetIdTransactionsOptions(assetId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AssetsAssetIdTransactionsOptions(assetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AssetsOptions(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AssetsOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} roundNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2BlocksRoundNumberOptions(roundNumber: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2BlocksRoundNumberOptions(roundNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2TransactionsOptions(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2TransactionsOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} txid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2TransactionsTxidOptions(txid: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2TransactionsTxidOptions(txid, options).then((request) => request(this.axios, this.basePath));
    }
}


